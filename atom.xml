<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秋染蒹葭</title>
  
  <subtitle>会当凌绝顶，一览众山小</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhyjor.github.io/"/>
  <updated>2023-10-11T02:22:23.800Z</updated>
  <id>https://zhyjor.github.io/</id>
  
  <author>
    <name>zhyjor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://zhyjor.github.io/2023/10/11/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E4%B8%89%EF%BC%9Awebpack%E6%89%93%E5%8C%85%E8%B0%83%E4%BC%98/"/>
    <id>https://zhyjor.github.io/2023/10/11/前端性能优化之三：webpack打包调优/</id>
    <published>2023-10-11T02:22:23.800Z</published>
    <updated>2023-10-11T02:22:23.800Z</updated>
    
    <content type="html"><![CDATA[<p>c</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;c&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack的细节之scopehoisting</title>
    <link href="https://zhyjor.github.io/2023/03/15/webpack%E7%9A%84%E7%BB%86%E8%8A%82%E4%B9%8Bscopehoisting/"/>
    <id>https://zhyjor.github.io/2023/03/15/webpack的细节之scopehoisting/</id>
    <published>2023-03-15T06:53:52.000Z</published>
    <updated>2023-10-11T02:22:23.800Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>参考资料</strong><br><a href=""></a></p><p><img src="https://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.zhyjor.com/wexin.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="dev" scheme="https://zhyjor.github.io/categories/dev/"/>
    
    
      <category term="dev" scheme="https://zhyjor.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>isolatedModules的使用</title>
    <link href="https://zhyjor.github.io/2023/03/15/isolatedModules%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhyjor.github.io/2023/03/15/isolatedModules的使用/</id>
    <published>2023-03-15T06:48:24.000Z</published>
    <updated>2023-10-11T02:22:23.796Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>参考资料</strong><br><a href=""></a></p><p><img src="https://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.zhyjor.com/wexin.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="dev" scheme="https://zhyjor.github.io/categories/dev/"/>
    
    
      <category term="dev" scheme="https://zhyjor.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>TreeShaking中的SideEffict</title>
    <link href="https://zhyjor.github.io/2023/03/15/TreeShaking%E4%B8%AD%E7%9A%84SideEffict/"/>
    <id>https://zhyjor.github.io/2023/03/15/TreeShaking中的SideEffict/</id>
    <published>2023-03-15T06:47:33.000Z</published>
    <updated>2023-10-11T02:22:23.792Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>参考资料</strong><br><a href=""></a></p><p><img src="https://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.zhyjor.com/wexin.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="dev" scheme="https://zhyjor.github.io/categories/dev/"/>
    
    
      <category term="dev" scheme="https://zhyjor.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>深度体验Rspack</title>
    <link href="https://zhyjor.github.io/2023/03/15/%E6%B7%B1%E5%BA%A6%E4%BD%93%E9%AA%8CRspack/"/>
    <id>https://zhyjor.github.io/2023/03/15/深度体验Rspack/</id>
    <published>2023-03-15T02:57:17.000Z</published>
    <updated>2023-10-11T02:22:23.808Z</updated>
    
    <content type="html"><![CDATA[<p>楼下的白玉兰花开了，树梢已经悄悄爬到了6楼高了，一树的玉兰花开的特别热烈。在家里的阳台上就能看到，仔细闻还能花香。春风不燥，阳光正好，春天也终于到了</p><p>前端构建圈这段时间异常热闹，基于Rust的构建工具极度内卷，本着「能被rust重写的都将被rust重写」的真理，Turbopack刚发布不久，3月10号，ByteDance发布了基于Rust的Rspack，字面理解Rust + Webpack。相比于Turbopack发布时大家都在关注它能比vite快多少的，<a href="https://github.com/yyx990803/vite-vs-next-turbo-hmr/discussions/8" target="_blank" rel="external">甚至惹的尤大都下场了</a>，Rspack的发布得到了更多社区上支持，比如 Monorepo 框架 Nx 已经对其提供官方支持(<a href="https://blog.nrwl.io/rspack-getting-up-to-speed-with-nx-4c34540bccf2" target="_blank" rel="external">Rspack — Getting up to speed with Nx</a>)；“Rspack 已经兼容webpack生态的主要配置，并且在内部业务落地的生成环境”</p><p>本文主要分享一下试用 Rspack 的体验，闲言少叙，进入正题<br><a id="more"></a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>先看一下<a href="https://www.rspack.dev/zh/guide/introduction.html" target="_blank" rel="external">官方文档</a>：</p><blockquote><p>Rspack（读音为 /‘ɑrespæk/,）是一个基于 Rust 的高性能构建引擎， 具备与 Webpack 生态系统的互操作性，可以被 Webpack 项目低成本集成，并提供更好的构建性能。<br>到今天（2023 年 3 月）为止 Rspack 已经开发了 11 个月，虽然 Rspack 仍处于比较早期的状态，且缺失了一些 webpack 的功能，但根据二八原则，目前的功能已经能够满足大多数项目的需求。同时，我们已经在内部的多个业务上完成了落地，取得了 5~10 倍编译性能的提升。<br>Rspack 已经完成了对 webpack 主要配置的兼容，并且适配了 webpack 的 loader 架构。目前，你已经可以在 Rspack 中无缝使用你熟悉的各种 loader，如 babel-loader、less-loader、sass-loader 等等。我们的长期目标是完整地支持 loader 特性，未来你可以在 Rspack 中使用那些更加复杂的 loader</p></blockquote><p>我们关注几个重点信息：</p><ol><li>缺失一些 webpack 的功能，但是已经能够满足大多数项目的需求</li><li>已经在内部的多个业务上完成了落地，取得了 5~10 倍编译性能的提升</li><li>完成了对 webpack 主要配置的兼容，并且适配了 webpack 的 loader 架构</li></ol><p>综上，假如没有较复杂的loader或其他配置的话，基于webpack的项目的项目是可以直接迁移的，接下来使用CRA新建一个应用，然后配置迁移为Rspack，通过这个过程来评估一下迁移复杂度，以及迁移后的性能是否真的能有5～10倍的提高</p><h2 id="webpack-2-rspack"><a href="#webpack-2-rspack" class="headerlink" title="webpack 2 rspack"></a>webpack 2 rspack</h2><p>首先放上本次测试的<a href="https://github.com/zhyjor/rspack-measure" target="_blank" rel="external">代码仓库</a>，可以直接通过下面的命令运行，查看结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># rspack</span></div><div class="line">npm run dev:rs</div><div class="line">npm run build:re</div><div class="line"></div><div class="line"><span class="comment"># webpack</span></div><div class="line">npm run dev</div><div class="line">npm run build</div></pre></td></tr></table></figure></p><p>先说结论，虽然CRA创建的项目相对比较简单，但也基本覆盖了基本的配置了，所以配置的修改也具有一定的参考意义。</p><ol><li>配置较简单，内置了对ts,js,css,file的默认支持，配置文件夹较简单</li><li>热更新，项目较小速度差距不明显，文档不够完善，完全找不到devServer是怎么配置的，而且热更新的日志明显还是 <code>webpack-dev-server</code>的 <img src="https://static.zhyjor.com/blog/25A01D17-A276-4390-92CC-99D9941D3542.png" alt=""></li><li>构建速度如下图，分别是2100ms和115ms，可见速度提升还是很明显的<img src="https://static.zhyjor.com/blog/EEAF2230-5757-4086-A3DE-9FF918C55E6D.png" alt="">, <img src="https://static.zhyjor.com/blog/973DA473-6AC9-47F3-B7E9-27614D38D807.png" alt=""></li><li>构建物文件大小，相差不大</li></ol><p>官方也提供了<a href="https://www.rspack.dev/zh/misc/benchmark.html" target="_blank" rel="external">测试Benchmark</a>，有兴趣的可以自己试试</p><h2 id="可以使用了吗"><a href="#可以使用了吗" class="headerlink" title="可以使用了吗"></a>可以使用了吗</h2><p>Rspack 已经完成了对 webpack 主要配置的兼容，并且适配了 webpack 的 loader 架构, 几乎可以无缝切换到 webpack 中经常使用的各种loader。而且按照官方的说法会长期完整支持webpack的loader特性，那可以遇见的一段时间内，是可以用起来的，速度比webpack快多了。</p><p>去年 Vercel 发布的 Turbopack 也是基于 Rust 并且主打高性能的，但是 Turbopack 并未对 webpack 的生态进行兼容，这样就很难利用上层现有的生态和框架，这也是 rspack 的优势。</p><p>另外官方还提到了缓存能力</p><blockquote><p>目前 Rspack 对缓存支持还比较简单，仅支持了内存级别的缓存，未来我们会建设更强的缓存能力，包括可迁移的持久化缓存，这将带来更大的想象空间，如在 monorepo 里不同的机器上都可以复用 Rspack 的云端缓存，提升大型项目的缓存命中率<br>大型项目的缓存能力一直是一个痛点，尤其是在云构建的情况下，缓存带来的时间的节省是非常可观的，可以期待一下。当然假如做到了云端缓存，能做当然也就是不仅仅是云端缓存的事情了，这里也和 vercel turbo （<a href="https://vercel.com/docs/concepts/monorepos/remote-caching#" target="_blank" rel="external">Remote Caching</a>） 有了一些重叠的想法，可以看一下 rspack 究竟可以走多远。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://www.zhihu.com/question/562349205/answer/2733040669" target="_blank" rel="external">Anthony Fu在评价Turbopack</a>里说：“我一直认为好的设计对性能的影响远比语言带来的提升更大，语言性能的加成更像一个常量系数，单纯更换语言只能带来有限的提升，在讨论更换语言以获得更好性能的时候，我们是不是应该问一句 - 那代价是什么？”。深以为然，目前 rspack 确实在代价控制这个方面做的更好一些，兼容了 webpack 生态，同时保持和 webpack 团队的工作关系，这样让切换成本低了很多，期待 rspack 能走的更远。</p><p>最后，生命不息，折腾不止，假如有想法，就用起来吧</p><p><strong>参考资料</strong><br><a href=""></a></p><p><img src="https://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;楼下的白玉兰花开了，树梢已经悄悄爬到了6楼高了，一树的玉兰花开的特别热烈。在家里的阳台上就能看到，仔细闻还能花香。春风不燥，阳光正好，春天也终于到了&lt;/p&gt;
&lt;p&gt;前端构建圈这段时间异常热闹，基于Rust的构建工具极度内卷，本着「能被rust重写的都将被rust重写」的真理，Turbopack刚发布不久，3月10号，ByteDance发布了基于Rust的Rspack，字面理解Rust + Webpack。相比于Turbopack发布时大家都在关注它能比vite快多少的，&lt;a href=&quot;https://github.com/yyx990803/vite-vs-next-turbo-hmr/discussions/8&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;甚至惹的尤大都下场了&lt;/a&gt;，Rspack的发布得到了更多社区上支持，比如 Monorepo 框架 Nx 已经对其提供官方支持(&lt;a href=&quot;https://blog.nrwl.io/rspack-getting-up-to-speed-with-nx-4c34540bccf2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Rspack — Getting up to speed with Nx&lt;/a&gt;)；“Rspack 已经兼容webpack生态的主要配置，并且在内部业务落地的生成环境”&lt;/p&gt;
&lt;p&gt;本文主要分享一下试用 Rspack 的体验，闲言少叙，进入正题&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="https://zhyjor.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Rspack" scheme="https://zhyjor.github.io/tags/Rspack/"/>
    
      <category term="Rust" scheme="https://zhyjor.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>开发者需要弄懂的 Babel Polyfill</title>
    <link href="https://zhyjor.github.io/2023/03/02/Polyfill/"/>
    <id>https://zhyjor.github.io/2023/03/02/Polyfill/</id>
    <published>2023-03-02T03:11:20.000Z</published>
    <updated>2023-10-11T02:22:23.792Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要解答两个问题</p><ol><li>我是业务开发者，我该如何配置Polyfill</li><li>我是Library开发者，我该如何配置Polyfill</li></ol><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为前端开发者，babel配置问题是一个绕不开的问题，也是一个相对复杂的问题，因为babel有太多的包了，比如：<code>@babel/preset-env</code>、<code>@babel/plugin-transform-runtime</code>、<code>@babel/runtime</code>、<code>core-js</code>、<code>@babel/polyfills</code>、<code>babel-polyfills</code>等等。</p><p>很多时候脚手架比如CRA、dva等，已经帮我们完成了项目最初的配置了，让我们能做到开箱即用，这样隐藏了一些配置，让Babel配置变得更黑盒，当我们想手动改一些配置的时候就会遇到很多奇奇怪怪的错误。想手动配置好一个项目，或者想学习一下babel的配置，就需要先弄懂这些包都是做什么的，正式解决本文的两个问题之前，先简单了解一下相关的基础知识</p><h3 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="@babel/preset-env"></a>@babel/preset-env</h3><p>从 babel@v7 开始，正式移除了对 stage presets 的支持，提供了新的<code>@babel/preset-env</code>方案，这里贴上官方的解释<a href="https://babeljs.io/blog/2018/07/27/removing-babels-stage-presets" target="_blank" rel="external">Removing Babel’s Stage Presets</a>。主要原因是维护基于stage0-state4的方案维护成本过高，另外就是过早的提供某些提案的支持，可能存在被滥用的风险。</p><blockquote><p>@babel/preset-env is a smart preset that allows you to use the latest JavaScript without needing to micromanage which syntax transforms (and optionally, browser polyfills) are needed by your target environment(s). This both makes your life easier and JavaScript bundles smaller!</p></blockquote><p>通过<a href="https://babeljs.io/docs/babel-preset-env.html" target="_blank" rel="external">官方文档</a>的描述，我们可以看到<code>@babel/preset-env</code> 做的是按需转换 JavaScript 最新的 syntax（主要指一些关键字），同时可以通过配置支持 JavaScript 中的一些最新的api（比如Array.from等）。index</p><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要解答两个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我是业务开发者，我该如何配置Polyfill&lt;/li&gt;
&lt;li&gt;我是Library开发者，我该如何配置Polyfill&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Babel" scheme="https://zhyjor.github.io/categories/Babel/"/>
    
    
      <category term="Babel" scheme="https://zhyjor.github.io/tags/Babel/"/>
    
      <category term="PWA" scheme="https://zhyjor.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>深入理解koa之一：20行代码实现的洋葱圈中间件模型</title>
    <link href="https://zhyjor.github.io/2023/01/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3koa%E4%B9%8B%E4%B8%80%EF%BC%9A20%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B4%8B%E8%91%B1%E5%9C%88%E6%A8%A1%E5%9E%8B/"/>
    <id>https://zhyjor.github.io/2023/01/13/深入理解koa之一：20行的实现的洋葱圈模型/</id>
    <published>2023-01-13T06:59:04.000Z</published>
    <updated>2023-10-11T02:22:23.808Z</updated>
    
    <content type="html"><![CDATA[<p>下雨了，也快过年了，很多人应该都已经确定回家的行程了吧，下雨当然不能阻挡回家的脚步。最喜欢在家里的柿子树下听着外面爆竹的声音，那一刻年味儿就回来了</p><p>闲言少叙，开始正文</p><a id="more"></a><p>koa想必很多人直接或间接的都用过，其源码不知道阅读本文的你有没有看过，相当精炼，本文想具体说说koa的中间件模型，一起看看<a href="https://github.com/koajs/compose" target="_blank" rel="external">koa-compose</a>的源码，这也是koa系列的第一篇文章，后续会更新一下koa相关的其他知识点</p><h2 id="koa中间件demo"><a href="#koa中间件demo" class="headerlink" title="koa中间件demo"></a>koa中间件demo</h2><p>先让我们启动一个koa服务<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// app.js</span></div><div class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> koa();</div><div class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'进入第一个中间件'</span>)</div><div class="line">  next();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'退出第一个中间件'</span>)</div><div class="line">&#125;)</div><div class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'进入第2个中间件'</span>)</div><div class="line">  next();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'退出第2个中间件'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'进入第3个中间件'</span>)</div><div class="line">  next();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'退出第3个中间件'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.use(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</div><div class="line">  ctx.body = <span class="string">'hello koa'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">app.listen(<span class="number">8080</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'服务启动，监听8080端口'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>上述的服务在访问的时候会得到如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">服务启动，监听8080端口</div><div class="line">进入第1个中间件</div><div class="line">进入第2个中间件</div><div class="line">进入第3个中间件</div><div class="line">退出第3个中间件</div><div class="line">退出第2个中间件</div><div class="line">退出第1个中间件</div></pre></td></tr></table></figure><p>上面的返回结果有点像一个递归的过程，从现象上看当中间件调用next()的时候，函数会暂停并进入到下一个中间件，当执行了最后一个中间件后，执行代码会回溯上游中间件，并执行next()之后的代码，这就是koa的核心能力，洋葱圈模型</p><h3 id="洋葱圈模型"><a href="#洋葱圈模型" class="headerlink" title="洋葱圈模型"></a>洋葱圈模型</h3><p>先看一张经典的洋葱圈模型的示意图：</p><p><img src="https://lxchuan12.gitee.io/assets/img/models.0be9c375.png" alt=""></p><p>在开发过程中，可以将next()之前的代码理解为<strong>捕获阶段</strong>, 而next()之后的代码可以理解为<strong>释放阶段</strong>，开发者结合这两个状态可以实现一些有趣的操作，比如记录一次请求的时间：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">responseTime</span>(<span class="params">ctx, next</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</div><div class="line">  <span class="keyword">await</span> next();</div><div class="line">  <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start;</div><div class="line">  ctx.set(<span class="string">'X-Response-Time'</span>, <span class="string">`<span class="subst">$&#123;ms&#125;</span>ms`</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">app.use(responseTime);</div></pre></td></tr></table></figure></p><p>使用洋葱圈模型可以直接将响应时间记录的操作解耦出来，这样就不需要再去对称的写在业务逻辑中了，这是怎么实现的呢？</p><h2 id="洋葱圈模型的实现，koa-compose"><a href="#洋葱圈模型的实现，koa-compose" class="headerlink" title="洋葱圈模型的实现，koa-compose"></a>洋葱圈模型的实现，koa-compose</h2><p>我们通过<code>app.use()</code>添加了很多函数，这些函数最终传递给了compose函数，先贴上koa-compose的源码，这里笔者删除掉了校验入参的一些非主干逻辑，我们可以看到代码也就18行，非常简单，接下来让我们一行一行的去看一下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">middleware</span>) </span>&#123;</div><div class="line">  <span class="comment">// 返回一个匿名函数，next为可选参数</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</div><div class="line">    <span class="comment">// 记录当前执行位置的游标</span></div><div class="line">    <span class="keyword">let</span> index = <span class="number">-1</span></div><div class="line">    <span class="comment">// 从第一个中间件开始，串起所有中间件</span></div><div class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>)</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</div><div class="line">      <span class="comment">// 为了不破坏洋葱圈模型，不允许在单个中间件中执行多次next函数</span></div><div class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'next() called multiple times'</span>))</div><div class="line">      <span class="comment">// 更新游标</span></div><div class="line">      index = i</div><div class="line">      <span class="keyword">let</span> fn = middleware[i]</div><div class="line">      <span class="comment">// 判断边界，假如已经到到边界了，可执行外部传入的回调</span></div><div class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next</div><div class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 核心处理逻辑，进入fn的执行上下文的时候，dispatch就是通过绑定下一个index，变成了next，进入到下一个中间件</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)))</div><div class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>compose接收一个的函数数组<code>[fn1, fn2, fn3, ...]</code>，compose调用后，返回了一个匿名函数，匿名函数接收两个参数</p><ul><li>第一个参数是上下文，对于koa的上下文不在本文的探究范围，我们只要记得这个是在各个中间件中的共享的就可以了</li><li>第二个参数标记为next，可选参数，在中间件执行的最后检查执行，这个和自定义的中间件中的next不完全一样，一般是初始化返回了匿名函数后，调用方自己指定，用于处理一下默认逻辑</li></ul><p>通过源码可以看出，compose是提供了一个洋葱模型完全执行的回调，通过把函数存储起来，用next作为钥匙，串起了我们所有的中间件，其核心代码就是：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)))</div></pre></td></tr></table></figure></p><p>进入fn的执行上下文的时候，dispatch就是通过绑定下一个index，变成了next，进入到下一个中间件。另外fn（中间件函数）可以是个异步函数，<code>Promise.resolve</code>会等到内部异步函数resolve之后触发</p><h3 id="单次调用限制"><a href="#单次调用限制" class="headerlink" title="单次调用限制"></a>单次调用限制</h3><p>假如在单个中间件中执行多次next函数的话，会造成下游的中间件多次执行，这样就破坏了洋葱圈模型，因此限制了在单个中间件中只能执行一次next函数，实现方式时在函数记录了一个游标index，初始值是-1；这个游标会记录当前执行到哪个中间件，用来禁止在中间件中多次调用next函数</p><p>在一个中间件内多次调用next的时候，你就会收到下面这个报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UnhandledPromiseRejectionWarning: <span class="built_in">Error</span>: next() called multiple times</div></pre></td></tr></table></figure><h2 id="koa-compose与流程引擎"><a href="#koa-compose与流程引擎" class="headerlink" title="koa-compose与流程引擎"></a>koa-compose与流程引擎</h2><p><code>koa-compose</code>不仅仅只是koa的一个依赖包，在有些场景下完全可以作为一个独立的工具来使用的，这里模拟一个代码检测工具的应用，完全可以作为一个流程引擎来使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> koaCompose = <span class="built_in">require</span>(<span class="string">'koa-compose'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span> = (<span class="params">ctx, next</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'download code'</span>);</div><div class="line">  next();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span> = (<span class="params">ctx, next</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'check style'</span>);</div><div class="line">  next();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">post</span> = (<span class="params">ctx, next</span>) </span>&#123;</div><div class="line">  next();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'post result'</span>, ctx.result);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clean</span> = (<span class="params">ctx, next</span>) </span>&#123;</div><div class="line">  next();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'clean temp, remove code'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> flowEngine = koaCompose([download, check, post, clean]);</div><div class="line">flowEngine(ctx <span class="keyword">as</span> Context);</div></pre></td></tr></table></figure></p><p>上述可以看作一个基于koa-compose实现的流程引擎，在node中，我们会经常处理一些多阶段的任务，完全可以通过这样的方式来实现</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>koa的洋葱圈模型在面试中经常会被问到，建议可以写一下、理解一下<code>koa-compose</code>的源码；另外<code>koa-compose</code>作为一个流程引擎也是一个很有用的工具，在有些场景下会有意想不到的效果</p><p><strong>参考资料</strong><br><a href="https://github.com/demopark/koa-docs-Zh-CN/blob/master/guide.md#debugging-koa" target="_blank" rel="external">koa-docs-Zh-CN</a><br><a href="https://segmentfault.com/a/1190000013447551" target="_blank" rel="external">https://segmentfault.com/a/1190000013447551</a><br><a href="https://juejin.cn/post/6844903496257585160" target="_blank" rel="external">https://juejin.cn/post/6844903496257585160</a><br><a href="https://ata.alibaba-inc.com/articles/91629?spm=ata.23639746.0.0.85d0152bHZduJX" target="_blank" rel="external">https://ata.alibaba-inc.com/articles/91629?spm=ata.23639746.0.0.85d0152bHZduJX</a><br><a href="https://juejin.cn/post/6855129007508488206#heading-5" target="_blank" rel="external">https://juejin.cn/post/6855129007508488206#heading-5</a><br><a href="https://lxchuan12.gitee.io/koa/#_6-koa-compose-%E6%BA%90%E7%A0%81-%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0" target="_blank" rel="external">https://lxchuan12.gitee.io/koa/#_6-koa-compose-%E6%BA%90%E7%A0%81-%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0</a><br><a href="https://github.com/demopark/koa-docs-Zh-CN/blob/master/guide.md#debugging-koa" target="_blank" rel="external">https://github.com/demopark/koa-docs-Zh-CN/blob/master/guide.md#debugging-koa</a><br><a href="https://github.com/koajs/compose/blob/master/index.js" target="_blank" rel="external">https://github.com/koajs/compose/blob/master/index.js</a></p><p><img src="https://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下雨了，也快过年了，很多人应该都已经确定回家的行程了吧，下雨当然不能阻挡回家的脚步。最喜欢在家里的柿子树下听着外面爆竹的声音，那一刻年味儿就回来了&lt;/p&gt;
&lt;p&gt;闲言少叙，开始正文&lt;/p&gt;
    
    </summary>
    
      <category term="node" scheme="https://zhyjor.github.io/categories/node/"/>
    
    
      <category term="js" scheme="https://zhyjor.github.io/tags/js/"/>
    
      <category term="node" scheme="https://zhyjor.github.io/tags/node/"/>
    
      <category term="后端" scheme="https://zhyjor.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="koa" scheme="https://zhyjor.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>SVG图标的使用姿势：搭建私有图标库</title>
    <link href="https://zhyjor.github.io/2023/01/06/Icon%E5%9B%BE%E6%A0%87%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"/>
    <id>https://zhyjor.github.io/2023/01/06/Icon图标的正确使用姿势/</id>
    <published>2023-01-06T03:08:15.000Z</published>
    <updated>2023-10-11T02:22:23.788Z</updated>
    
    <content type="html"><![CDATA[<p>天气转暖了，冬日暖阳让人整个都舒展了，周五了，偷偷摸摸鱼，最近少有的晴天，周末户外走起</p><p>闲言少叙，开始正文<br><a id="more"></a><br>随着svg的浏览器兼容性越来越好，图标的使用基本已经都已经是svg方案了。笔者最近自己找麻烦，搭建了一个公司内部的svg治理站点，可以理解为一个私有化的<a href="https://www.iconfont.cn/" target="_blank" rel="external">阿里巴巴图标库</a>。在对接历史svg治理的过程中，遇到了各种各样的问题。尤其是面对水平参差不齐的设计师的时候，导入到系统的svg也是五花八门的。除了需要在存储落盘前，将图标”洗干净”，还需要和设计师去沟通svg在前端的一些使用逻辑，让他们给出更规范的svg，这就是本文的背景。</p><h2 id="三种图标的引入方式"><a href="#三种图标的引入方式" class="headerlink" title="三种图标的引入方式"></a>三种图标的引入方式</h2><p>首先一般第三方组件库都会提供图标组件，比如antd提供了<code>@ant-design/icons</code>，一般在实际使用中是不够用的，这就需要自定义Icon，目前项目中自定义Icon有三种方式</p><ul><li>直接<code>import</code>图标<code>.svg</code>文件，然后作为<code>&lt;img&gt;</code>标签渲染</li><li>svg sprite，通过<code>svg-sprite-loader</code>插件，将指定文件夹内的所有<code>.svg</code>文件组装成一个大的<code>.svg</code>文件，在使用的时候通过<code>use</code>指定<code>symbol</code></li><li>第三种是笔者正在用的方式，相当于第二种的进阶方式，和<code>@ant-design/icons</code>提供的<code>createFromIconfontCN()</code>类似，通过自建svg治理服务，可以简单的使用团队共享出来的svg资源</li></ul><p>大多情况下，同一个图标会有三个状态：normal/hover/disabled，每个状态都会对应一种颜色，假如使用了第一种方案，我们就需要三个不同颜色的图标，而且很难实现在hover的时候，颜色transition的效果。而且假如项目接入了主题色的时候，或者设计师要修改颜色的时候，都会很麻烦</p><p>相比之下，第二种和第三种方式均使用了svg sprite的方式，可以通过css控制图标的颜色，那么只需要一个图标文件，就能满足不同颜色的需求，相比之下，这种方案比<code>&lt;img&gt;</code>的方案更好一些</p><h2 id="如何导出svg"><a href="#如何导出svg" class="headerlink" title="如何导出svg"></a>如何导出svg</h2><p>为了开发的方便，前端的很多同学会安装sketch，用sketch导出需要的icon很方便</p><ol><li>设计稿选中图标</li><li>在选中内容的情况下，sketch右下角点击「设为可导出」选项</li><li>格式选择「svg」，点击最下方的导出选中项</li></ol><p>简单三步，就可以导出svg文件，但是这样并不够</p><h2 id="sketch直接导出文件存在的问题"><a href="#sketch直接导出文件存在的问题" class="headerlink" title="sketch直接导出文件存在的问题"></a>sketch直接导出文件存在的问题</h2><h3 id="视觉面积不一致"><a href="#视觉面积不一致" class="headerlink" title="视觉面积不一致"></a>视觉面积不一致</h3><p>关于视觉面积的问题可以先看看这篇文章<a href="https://medium.muz.li/optical-effects-9fca82b4cd9a" target="_blank" rel="external">Optical Effects in User Interfaces</a><br>一般来说，sketch导出图标是按照图标的边界去导出的，但是图片的形态个不一样，造成图标的各个边界的大小也不一样，比如在下面的例子中，设计师为了保持正方形和圆形的视觉面积的一致，会把圆形的直径做的大一些<br><img src="https://cdn.nlark.com/yuque/0/2019/webp/164049/1564929081020-d9c3259c-9263-48e8-bc7d-42f928b0d8c1.webp?x-oss-process=image/format,png" alt=""></p><p>sketch按照图标的边界导出，最初导出的正方形icon的尺寸是400，圆形的尺寸是450，如果你直接通过<code>&lt;img&gt;</code>引入icon，在界面的宽度就会是400和450，这样确实可以保持视觉大小和设计稿保持一致，但是图标的位置大概率对不齐了，开发的时候就需要针对这种图标进行特殊处理。</p><p>假如设计师想统一调整两个图标大小的时候，比如调整到300，那就很难办了。因为一旦你将两个图标都改成300，那肯定圆的视觉面积较小；正确的做法是将正方形的宽度调整到300，而圆的宽度设置为大约337，相当于手动计算一下对应的尺寸，这也是一个办法。</p><p>除了这个问题，还有左右/上下重心的问题，比如三角形图标▶️，它的重心必然是偏左边一些，所以设计图上可能会适当的偏右，这里就不详细解释了。</p><p>这个问题的解决方法很简单，<strong>将所有的图标放到一个略大一些、统一尺寸的正方形区域内。在使用的时候指定一个统一的宽度就可以了</strong><br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/164049/1564930264387-2ade8072-5e93-4dc1-a87d-1707ca8237e4.jpeg" alt=""></p><h3 id="sketch-导出的-svg-不够「纯」"><a href="#sketch-导出的-svg-不够「纯」" class="headerlink" title="sketch 导出的 svg 不够「纯」"></a>sketch 导出的 svg 不够「纯」</h3><p>如果你观察过sketch导出的svg源码，你会发现里面有很多层xml节点，会有一些看不太懂的奇怪的标签和属性，svg代码不「纯」会导致一些问题，比如：</p><ul><li>体积更大，比如一些2k左右的图，可以优化到500b以内</li><li>难以自定义颜色，有些图标是通过<code>形状+填充(fill)</code>实现的，而有的时候又是<code>线条+描边(stroke)</code>实现的，而我们若要自定义颜色的话，则需要统一指定<code>fill</code>来实现</li><li>一些svg的属性不兼容，或者sketch导出的有问题，可能会导致在浏览器里打开的效果都有问题</li></ul><h2 id="如何正确输出svg图标"><a href="#如何正确输出svg图标" class="headerlink" title="如何正确输出svg图标"></a>如何正确输出svg图标</h2><p>一般的做法是：</p><ol><li>通过sketch导出</li><li>使用Adobe Illustrator（简称“AI”，是Adobe系统公司推出的基于向量的图形制作软件），重新编辑一遍：<ol><li>取消所有的「分组」，删除无关标签</li><li>将「描边」统一转换为「轮廓」</li><li>可以将一些形状做一些「合并」等操作</li><li>…</li><li>一般坐完这些事情，最终得到的svg文件内部只有一个<code>&lt;path&gt;</code>标签</li></ol></li><li>调整画布到一个统一的正方形区域，如果图标本身很特殊可能不需要</li><li>导出svg，并手动删除fill属性的颜色，这是为了可以通过css自定义颜色（彩色图标除外）</li><li>使用svgo命令压缩图标</li></ol><p>因为AI有一定的上手成本，可以要求设计师完成前3步，再将svg交付给我们，这里可以参考一下<a href="https://www.iconfont.cn/help/detail" target="_blank" rel="external">阿里巴巴图标库-绘制规则</a></p><h3 id="图标治理平台"><a href="#图标治理平台" class="headerlink" title="图标治理平台"></a>图标治理平台</h3><p>笔者在文章开头的位置，不是提到了搭建了一个图标治理平台吗，治理平台是怎么做的呢？其实和上面的流程一样，前三步也是需要设计师来完成，然后设计师导出svg后直接上传，然后会在后端根据页面的的「是否保留颜色」来控制是否去除fill属性，同时使用svgo进行文件的压缩，完成了这一系列的操作后才会将文件落盘存储</p><p>这里画张图简单说一下图标治理平台做了什么事情：<br><img src="https://static.zhyjor.com/blog/fadfadfadfewrccadcacadadfadfadf.png" alt=""></p><p>其中下载svg sprite到本地的方式可以参考一下<code>createFromIconfontCN</code>方法的实践，通过加载一个cdn上的js，在这个js中将svg插入到dom中，在组件中直接使用<code>&lt;use&gt;</code>即可完成图标的使用</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在项目中使用可<code>svg-sprite-loader</code>或者<code>svgr</code>来管理本地的图标，封装自定义icon，这几本已经满足日常需求了，假如你想将图标都维护起来的话，肯定还是选择部署私有的在线的图标治理平台，自己封装<code>createFromIconfontCN()</code>方法，直接使用cdn上的资源，肯定是最方便的。</p><p>假如有想交流部署图标库经验的，欢迎在评论区留言</p><p><strong>参考资料</strong><br><a href="https://medium.muz.li/optical-effects-9fca82b4cd9a" target="_blank" rel="external">Optical Effects in User Interfaces</a></p><p><img src="https://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;天气转暖了，冬日暖阳让人整个都舒展了，周五了，偷偷摸摸鱼，最近少有的晴天，周末户外走起&lt;/p&gt;
&lt;p&gt;闲言少叙，开始正文&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="https://zhyjor.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zhyjor.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="svg" scheme="https://zhyjor.github.io/tags/svg/"/>
    
  </entry>
  
  <entry>
    <title>从源码的角度回答ReactHooks面试题</title>
    <link href="https://zhyjor.github.io/2022/12/08/%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9A%84%E8%A7%92%E5%BA%A6%E5%9B%9E%E7%AD%94ReactHooks%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://zhyjor.github.io/2022/12/08/从源码的角度回答ReactHooks面试题/</id>
    <published>2022-12-08T05:47:37.000Z</published>
    <updated>2023-10-11T02:22:23.800Z</updated>
    
    <content type="html"><![CDATA[<p>杭州已经不看健康码了，某种程度上来说YQ已经结束了，但某种程度上YQ又刚刚开始。无论是谁在这个冬天都要保护好自己，明年春暖花开的时候，肯定就是真正的春天到了</p><p>闲言少叙，开始正文<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇文章<a href="https://juejin.cn/post/7172903844366516260" target="_blank" rel="external">《都React V18了，还不会正确使用React Hooks吗，万字长文解析Hooks的常见问题》</a>说到了React Hooks的一些常见问题，本文让我们继续深入react hooks，结合几个常见的面试题，从源码角度分析一下react hooks，从源码的角度回答一下这些问题。</p><p>本文的React源码基于最新的版本 <a href="https://github.com/facebook/react/tree/v18.2.0" target="_blank" rel="external">V18.2.0</a></p><h2 id="带着问题看源码"><a href="#带着问题看源码" class="headerlink" title="带着问题看源码"></a>带着问题看源码</h2><p>从React V16.8 发布以来 Hooks API 以来，社区出现了很多针对Hooks源码分析的文章。但是源码阅读本就是一个比较枯燥的事情，而且React源码也相对复杂，涉及了诸如Fiber、双缓冲之类相对不好整体理解的新概念，源码阅读起来没有那么顺畅。React Hooks又是面试会经常被问到的一个点，本文笔者不会长篇铺上代码，会结合几个面试中常见的问题，对 React Hooks 的源码进行分析，带着问题去分析源码，尽可能的使用更规范的答案，来回答这些面试题，同时对React Hooks源码有更深入的理解。</p><h2 id="常见的React-Hooks面试题"><a href="#常见的React-Hooks面试题" class="headerlink" title="常见的React Hooks面试题"></a>常见的React Hooks面试题</h2><h3 id="为什么可以在Function-Component中使用使用私有状态"><a href="#为什么可以在Function-Component中使用使用私有状态" class="headerlink" title="为什么可以在Function Component中使用使用私有状态"></a>为什么可以在Function Component中使用使用私有状态</h3><p>Function Component 和 Class Component 不同，Function Component 不能实例化，所有就不可以将私有状态挂在到实例上，组件每次重新渲染都会把Function重新执行一遍，函数内的变量就会重新初始化，这些状态在React内是怎么维护的呢<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 组件re-render的时候name，setName保存在哪里</span></div><div class="line"><span class="keyword">const</span> Comp = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> [name, setName] = uesState(<span class="string">''</span>);</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span>&#123;name&#125;<span class="tag">&lt;/&gt;</span></span></div><div class="line"><span class="xml">&#125;</span></div></pre></td></tr></table></figure></p><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>这个问题应该是所有人在使用hooks api的第一个疑惑，为什么React Function Component 每次渲染之后都能返回的之前的值，毋庸置疑的是React 肯定通过某种机制记录下来了更新操作，并将其结果记录并返回给下一次渲染了。但是这些状态记录在哪里了呢？这里先卖个关子，先看看下一个React Hooks的问题</p><h3 id="为什么不要在循环，条件或嵌套函数中调用hooks"><a href="#为什么不要在循环，条件或嵌套函数中调用hooks" class="headerlink" title="为什么不要在循环，条件或嵌套函数中调用hooks"></a>为什么不要在循环，条件或嵌套函数中调用hooks</h3><p>React官方文档中明确说明了这条Hooks调用顺序的限制</p><blockquote><p>不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层以及任何 return 之前调用Hooks</p></blockquote><p>假如我们这样使用了就会遇到eslint的提醒，比如下面的🌰:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Comp = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">if</span>(props.disable) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="string">''</span>);</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span>&#123;name&#125;<span class="tag">&lt;/&gt;</span></span></div><div class="line"><span class="xml">&#125;</span></div></pre></td></tr></table></figure></p><p>上面的例子不出意外的会出现一个警告<code>React Hook &quot;useState&quot; is called conditionally. React Hooks muse be called in the exact same order in every render</code></p><p>这种用法也很常见，但是为什么React Hooks就能不兼容呢</p><h4 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h4><p>这个问题Rudi Yardley有个回答笔者感觉特别好：<a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="external">React hooks: not magic, just arrays</a>；因为hooks维护了一系列的数组，假如在不同的render返回的返回的hooks不同，内部游标就无法做到正确的匹配。</p><p>这个问题也刚好匹配到了第一个问题，函数组件的状态就是维护到了这些数组中，根据组件内书写的hooks的顺序，按顺序返回，这就解释了为什么Function Component 可以记录私有变量。</p><p>下面从React源码的角度看看这个问题</p><h4 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h4><p>首先我们不关注不相关的部分，react的源码逻辑很深，假如过于关注某些细节很容易陷入其中，找不到重点，我们直接跳到关键位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// react-reconciler/src/ReactFiberHooks.js</span></div><div class="line"><span class="comment">// HooksDispatcherOnMount，挂载阶段的useState</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountState</span>&lt;<span class="title">S</span>&gt;(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  hook.memoizedState = hook.baseState = initialState;</div><div class="line">  <span class="keyword">const</span> queue: UpdateQueue&lt;S, BasicStateAction&lt;S&gt;&gt; = &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">const</span> dispatch = dispatchSetState.bind();</div><div class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// HooksDispatcherOnUpdate，更新阶段的useState</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateState</span>&lt;<span class="title">S</span>&gt;(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> updateReducer(basicStateReducer, (initialState: any));</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">const</span> hook = updateWorkInProgressHook();</div><div class="line">      <span class="keyword">const</span> queue = hook.queue;</div><div class="line">      <span class="keyword">const</span> dispatch: Dispatch&lt;A&gt; = (queue.dispatch: any);</div><div class="line">      <span class="keyword">return</span> [hook.memoizedState, dispatch];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 关键点指向mountWorkInProgressHook</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountWorkInProgressHook</span>(<span class="params"></span>): <span class="title">Hook</span> </span>&#123;</div><div class="line">  <span class="comment">// 创建一个节点</span></div><div class="line">  <span class="keyword">const</span> hook: Hook = &#123;</div><div class="line">    memoizedState: <span class="literal">null</span>,</div><div class="line"></div><div class="line">    baseState: <span class="literal">null</span>,</div><div class="line">    baseQueue: <span class="literal">null</span>,</div><div class="line">    queue: <span class="literal">null</span>,</div><div class="line"></div><div class="line">    next: <span class="literal">null</span>,</div><div class="line">  &#125;;</div><div class="line">  <span class="comment">// 判断这是不是链表的第一个节点</span></div><div class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</div><div class="line">    <span class="comment">// 若这是链表的第一个节点，将链表指针memoizedState指向当前hook</span></div><div class="line">    <span class="comment">// currentlyRenderingFiber 是 workInProgress 指向的 fiber 节点，workInProgress本文就不做分解了，后续可以细说</span></div><div class="line">    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 若这不是链表的第一个节点，则直接添加节点放到列表的最后</span></div><div class="line">    workInProgressHook = workInProgressHook.next = hook;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> workInProgressHook;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在mount阶段，每调用一次创建 hook 的函数，不论是什么 hook，只要是在这个函数组件内定义的，都会添加到workInProgressHook链表中，<strong>一个Function Component中定义的所有的hooks节点都会放到链表内，并存放在通过指针memoizedState保持引用，可以从该属性中获取链表的指针。</strong>这些 hooks 的调用顺序，其实就是其添加在链表上的顺序。在re-render时，也会按照添加的顺序来执行，所以需要hooks在函数顶部声明，同时不能在判断语句中声明，否则可能会引起hooks的错乱</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>组件在挂在阶段是通过mountWorkInProgressHook来生成hooks并挂载到链表上的，我们都知道组件的生命周期内，还包含更新，在mounted阶段，初始节点已经把所有的 hooks 都挂载在链表中了，在update阶段的更新操作是怎么处理的呢，这里不做详细说明了，可以去看看<code>updateWorkInProgressHook</code>。</p><h3 id="hooks的依赖跟踪是怎么实现的"><a href="#hooks的依赖跟踪是怎么实现的" class="headerlink" title="hooks的依赖跟踪是怎么实现的"></a>hooks的依赖跟踪是怎么实现的</h3><p>你写代码的时候会不会遇到过在Effect中依赖了某个state，但是忘记将其加入到依赖中了，比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Comp = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> [keyword, setKeyword] = useState(<span class="string">''</span>);</div><div class="line">  <span class="keyword">const</span> [pageNumber, setPageNumber] = useState(<span class="number">0</span>);</div><div class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;doFetch(keyword, pageNumber)&#125;, [pageNumber])</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span>&#123;keyword&#125;<span class="tag">&lt;/&gt;</span></span></div><div class="line"><span class="xml">&#125;</span></div></pre></td></tr></table></figure></p><p>上述的代码会造成useEffect在keyword变化的时候不会执行fetch，代码执行的时机或者执行结果会出现异常。那为什么useEffect中依赖的state必须加到依赖项中呢</p><p>其实useEffect(), useMemo(), useCallback() 等hooks中，第2个参数是依赖项，react是怎么实现依赖跟踪的呢</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>我们还是直接前往关键代码位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /packages/react-reconciler/src/ReactFiberHooks.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffectImpl</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  <span class="regexp">//</span> ...</span></span></div><div class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></div><div class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></div><div class="line"><span class="function">) </span>&#123;</div><div class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</div><div class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</div><div class="line">    <span class="keyword">const</span> prevEffect = currentHook.memoizedState;</div><div class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</div><div class="line">      <span class="keyword">const</span> prevDeps = prevEffect.deps;</div><div class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</div><div class="line">        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  currentlyRenderingFiber.flags |= fiberFlags;</div><div class="line">  hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从上面的代码可以看出，假如没有设置依赖项，或设置的依赖项为 null，则该 hook 每次渲染时都会执行；若依赖项任何一项都没有变化，使用上一次渲染的结果。依赖项目的判断是怎么做的呢<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">areHookInputsEqual</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  nextDeps: Array&lt;mixed&gt;,</span></span></div><div class="line"><span class="function"><span class="params">  prevDeps: Array&lt;mixed&gt; | null,</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">boolean</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (prevDeps === <span class="literal">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// $FlowFixMe[incompatible-use] found when upgrading Flow</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) &#123;</div><div class="line">    <span class="comment">// $FlowFixMe[incompatible-use] found when upgrading Flow</span></div><div class="line">    <span class="keyword">if</span> (is(nextDeps[i], prevDeps[i])) &#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在HooksDispatcherOnUpdate阶段，上面的代码会比较两个依赖项中的每一项是否有变化，若任意的一项变化，就返回 false，表示两个依赖项不相等, hooks会重新执行；若都一样，则hooks还使用之前缓存的数据，而不会去执行effect，这就是hooks依赖跟踪机制</p><h3 id="useCallback和useMemo的区别是什么"><a href="#useCallback和useMemo的区别是什么" class="headerlink" title="useCallback和useMemo的区别是什么"></a>useCallback和useMemo的区别是什么</h3><p>首先useCallback我们经常用在包裹一个函数，避免组件re-render的时候生成一个新的函数，引起子组件re-render；一般我们会将useCallback和React.memo结合使用，可以参考一下上篇文章中关于<a href="https://juejin.cn/post/7172903844366516260#heading-4" target="_blank" rel="external">《用useCallback肯定能提升性能吗？》</a>的部分。而useMemo一般用于复杂的计算，优化一些不必要的计算，比如计算的相关参数都没有变化的时候，直接返回上一次的计算结果就好了，避免出现在当前组件中进行冗余的计算</p><p>可以看看这个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Children = React.memo(<span class="function">(<span class="params">props</span>) =&gt;</span> &lt;button onClick=&#123;props.doSubmit&#125;&gt;提交&lt;<span class="regexp">/button&gt;);</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">export default function Demo() &#123;</span></div><div class="line"><span class="regexp">  const [number, setNumber] = useState(0);</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">  const doSubmit = useCallback(() =&gt; &#123;</span></div><div class="line"><span class="regexp">    console.log(`Number: $&#123;number&#125;`); /</span><span class="regexp">/ 每次输出都是初始值</span></div><div class="line"><span class="regexp">  &#125;, [number]); /</span><span class="regexp">/ 把`text`写在依赖数组里</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">  const memoValue = React.useMemo(() =&gt; &#123;</span></div><div class="line"><span class="regexp">    return Array(100000).fill('').map(v =&gt; /</span>*数据计算*<span class="regexp">/ v);</span></div><div class="line"><span class="regexp">  &#125;, [number]);</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">  return (</span></div><div class="line"><span class="regexp">    &lt;&gt;</span></div><div class="line"><span class="regexp">      &lt;input value=&#123;number&#125; onChange=&#123;(e) =&gt; setNumber(e.target.value)&#125; /</span>&gt;</div><div class="line">      &lt;Children doSubmit=&#123;doSubmit&#125; /&gt;</div><div class="line">    &lt;<span class="regexp">/&gt;</span></div><div class="line"><span class="regexp">  );</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>useCallback和useMemo几乎完全一样，唯一的区别就是useCallback根据第二个参数（依赖项）缓存并返回第一个参数（回调函数），useMemo是根据第二个参数（依赖项）缓存并返回第一个参数（回调函数）的执行结果，<strong>两者一个缓存的回调函数，一个缓存的时回调函数的执行结果</strong></p><h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><p>在上述的分析中，我们可以发现所有的 hooks 在内部实现时，都会区分mount阶段和update阶段，useCallback和useMemo也是会区分的，我们主要关心一下update阶段的代码，依赖更新部分的能力可以参考上面的分析，这不做过多解释，让我们就直观的看看useCallback和useMemo的区别<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateCallback</span>&lt;<span class="title">T</span>&gt;(<span class="params">callback: T, deps: Array&lt;mixed&gt; | void | null</span>): <span class="title">T</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</div><div class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</div><div class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</div><div class="line">  <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</div><div class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 返回函数</span></div><div class="line">  hook.memoizedState = [callback, nextDeps];</div><div class="line">  <span class="keyword">return</span> callback;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateMemo</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  nextCreate: (</span>) =&gt; <span class="title">T</span>,</span></div><div class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></div><div class="line"><span class="function">): <span class="title">T</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</div><div class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</div><div class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</div><div class="line">  <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</div><div class="line">    <span class="keyword">return</span> prevState[<span class="number">0</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 计算结果</span></div><div class="line">  <span class="keyword">if</span> (shouldDoubleInvokeUserFnsInHooksDEV) &#123;</div><div class="line">    nextCreate();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">const</span> nextValue = nextCreate();</div><div class="line">  hook.memoizedState = [nextValue, nextDeps];</div><div class="line">  <span class="keyword">return</span> nextValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以直观的看到<code>hook.memoizedState</code>保存的分别是callback和nextValue，这样就可以解释两者一个缓存的回调函数，一个缓存的时回调函数的执行结果这个结果了</p><h3 id="useEffect和useLayoutEffect执行时机有什么区别"><a href="#useEffect和useLayoutEffect执行时机有什么区别" class="headerlink" title="useEffect和useLayoutEffect执行时机有什么区别"></a>useEffect和useLayoutEffect执行时机有什么区别</h3><p>先看看官方文档对这两个hooks的描述，先看看useEffect:</p><blockquote><p>该 Hook 接收一个包含命令式、且可能有副作用代码的函数。使用 useEffect 完成副作用操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后执行。默认情况下，effect 将在每轮渲染结束后执行，但你可以选择让它在只有某些值改变的时候才执行。</p></blockquote><p>再看看useLayoutEffect:</p><blockquote><p>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。</p></blockquote><h4 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h4><p>下面的代码可以看出，useEffect和useLayoutEffect的调用的函数其实是同一个，那两者的区别是什么呢<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateLayoutEffect</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></div><div class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></div><div class="line"><span class="function">): <span class="title">void</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> updateEffectImpl(UpdateEffect, HookLayout, create, deps);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其实关键点就是updateEffectImpl第一个参数fiberFlags的控制，分别是<code>PassiveEffect</code>和<code>UpdateEffect</code>,现在让给我们看一下两者在调度器Scheduler内的执行时机</p><p>React的一次状态更新，可以简单概括为两个阶段，构造fiber树（render）和渲染fiber树（commit），为了直观，我们依旧不去关心优先级，不去关心调度器的实现，只关注useEffect和useLayoutEffect回掉函数执行时机，当workInProgressFiber树构建完成，就会进入commit阶段，useEffect的副作用才会开始执行或销毁，commit阶段的内部执行也是很复杂但是不是这个问题重点，让我们直接跳过commit阶段不相关的部分，前往Effect的执行部分</p><p>commit的入口函数是<code>commitRoot --&gt; commitRootImpl</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRootImpl</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></div><div class="line"><span class="function"><span class="params">  recoverableErrors: null | Array&lt;CapturedValue&lt;mixed&gt;&gt;,</span></span></div><div class="line"><span class="function"><span class="params">  transitions: Array&lt;Transition&gt; | null,</span></span></div><div class="line"><span class="function"><span class="params">  renderPriorityLevel: EventPriority,</span></span></div><div class="line"><span class="function"><span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 异步调度effect</span></div><div class="line">  scheduleCallback(NormalSchedulerPriority, () =&gt; &#123;</div><div class="line">    flushPassiveEffects();</div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">  &#125;);</div><div class="line">  <span class="comment">// Before Mutation阶段</span></div><div class="line">  <span class="keyword">const</span> shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(</div><div class="line">      root,</div><div class="line">      finishedWork,</div><div class="line">    );</div><div class="line"></div><div class="line"> <span class="comment">// Mutation阶段</span></div><div class="line">  commitMutationEffects(root, finishedWork, lanes);</div><div class="line"> <span class="comment">// Layout阶段</span></div><div class="line">  commitLayoutEffects(finishedWork, root, lanes);</div><div class="line"></div><div class="line">  flushSyncCallbacks();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以明确的是，useLayoutEffect会在commit阶段中同步执行，回调函数会更早一点执行，可以在useLayoutEffects中进行一些可能影响dom的操作，其create中可以获取到最新的dom树且由于此时浏览器未进行绘制，这个时候操作dom可以避免一起一些浏览器的抖动行为，这部分逻辑就不再深入了，后续可以针对react的更新进行一次彻底的源码分析</p><h4 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h4><p>这个问题其实还有个延伸问题，useEffect和useLayoutEffect和Class Component中的生命周期如何对应等等，这个可以看看源码思考一下</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完上面的几个问题，我们基本也从几个片段看了一些Hooks的源码，现在我们应该对这几个问题有些相对清晰的认识了，但是似乎对react源码或者说react的更新过程有了一些更多的疑惑，这个可以让我们在后面的文章中继续分析</p><p>对本文或者react hooks有问题的，欢迎留言讨论</p><p><strong>参考资料</strong><br><a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="external">React hooks: not magic, just arrays</a></p><p><a href="https://juejin.cn/post/6932763604492140557#heading-8" target="_blank" rel="external">useEffect和useLayoutEffect源码浅析</a><br><a href="https://www.xiabingbao.com/post/react/react-hooks-rjp9x1.html" target="_blank" rel="external">React18 源码解析之 hooks 的挂载</a><br><a href="https://juejin.cn/post/6954352486312312845#heading-6" target="_blank" rel="external">【万字长文】React hooks 源码详解</a><br><a href="https://juejin.cn/post/6844904080758800392#heading-1" target="_blank" rel="external">React Hooks源码解析，原来这么简单～</a><br><a href="https://zhuanlan.zhihu.com/p/387939403" target="_blank" rel="external">突破Hooks所有限制，只要50行代码</a><br><a href="https://github.com/monsterooo/blog/issues/37" target="_blank" rel="external">useCallback、useMemo 分析 &amp; 差别</a><br><a href="https://article.itxueyuan.com/rxK3Rp" target="_blank" rel="external">深入理解 React useLayoutEffect 和 useEffect 的执行时机</a></p><p><img src="https://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;杭州已经不看健康码了，某种程度上来说YQ已经结束了，但某种程度上YQ又刚刚开始。无论是谁在这个冬天都要保护好自己，明年春暖花开的时候，肯定就是真正的春天到了&lt;/p&gt;
&lt;p&gt;闲言少叙，开始正文&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="https://zhyjor.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://zhyjor.github.io/tags/js/"/>
    
      <category term="React" scheme="https://zhyjor.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>都React V18了,还不会正确使用React Hooks吗,万字长文解析Hooks的常见问题</title>
    <link href="https://zhyjor.github.io/2022/12/01/%E9%83%BDReact%20V18%E4%BA%86%EF%BC%8C%E8%BF%98%E4%B8%8D%E4%BC%9A%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8Hooks%E5%90%97/"/>
    <id>https://zhyjor.github.io/2022/12/01/都React V18了，还不会正确使用Hooks吗/</id>
    <published>2022-12-01T06:13:21.000Z</published>
    <updated>2023-10-11T02:22:23.808Z</updated>
    
    <content type="html"><![CDATA[<p>杭州下雪了，想去西湖看雪了，雪后的杭州更有水墨画里的感觉了，一下雪杭州就成了临安</p><p>今天主要想说一下react hooks，react hooks是react v16.8 之后引入的API，现在react都已经到18了，hooks怎么还能不会用呢。hooks引入的目的是给函数式组件增加数据状态管理的能力，同时增加代码的可复用能力。但是同时hooks也是一个潘多拉魔盒，因为函数式组件不再只是单纯的一个纯函数了，可以在内部处理副作用了，使用不好就会经常遇到各种各样的问题，而且错误的使用方式也会引起re-render，引起一些性能上的问题</p><p>本文主要介绍hooks的常见的几个问题与最优实践，同时介绍一下随着react版本迭代的API的变化</p><p>闲言少叙，直接进入正文<br><a id="more"></a><br>首先，在使用之前，笔者还是想强调一下</p><p><strong>请配置上<code>eslint-plugin-react-hooks</code></strong><br><strong>请配置上<code>eslint-plugin-react-hooks</code></strong><br><strong>请配置上<code>eslint-plugin-react-hooks</code></strong></p><p>hooks的的使用确实很爽，但是和纯函数相比，还是有挺多反直觉的写法的，比如不能在判断语句中使用hooks。这就很容易有问题，我们需要使用工具来规避这些问题，来提醒我们有些写法是错误的。当然hooks的有其自己的合理性问题，我们暂时不做讨论，这个插件提醒可以保证让我们的写法是符合当前规范的，不至于出现低级问题</p><h2 id="异步调用的闭包问题"><a href="#异步调用的闭包问题" class="headerlink" title="异步调用的闭包问题"></a>异步调用的闭包问题</h2><p>统计1秒内按钮点击的次数，先看代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> [number, setNumber] = React.useState(<span class="number">0</span>);</div><div class="line">  <span class="keyword">const</span> click = <span class="function"><span class="params">()</span> =&gt;</span></div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      setNumber(number + <span class="number">1</span>);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;click&#125;</span>&gt;</span> 点击 &#123;number&#125; 次<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当多次点击的时候的时候，显示的点击次数错误。点击click方法内的闭包回调函数在组件render的时候捕获了number变量，为了解决这个问题可以使用函数方法来更新数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> click = <span class="function"><span class="params">()</span> =&gt;</span></div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      setNumber(<span class="function"><span class="params">number</span> =&gt;</span> number + <span class="number">1</span>);</div><div class="line">    &#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure></p><p>在调用状态更新函数的时候，会将准确的数据回调给当前的更新函数</p><h3 id="更近一步"><a href="#更近一步" class="headerlink" title="更近一步"></a>更近一步</h3><p>同样的，假如我们统计开屏3秒内的点击次数，在计时结束后，将点击次数发送给server端的时候，就会遇到另一个问题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> [number, setNumber] = React.useState(<span class="number">0</span>);</div><div class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="comment">// do fetch</span></div><div class="line">      <span class="built_in">console</span>.log(number);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      clearTimeout(timer);</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 依赖这里会有个警告</span></div><div class="line">  &#125;, []);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setNumber((c) =&gt; c + 1)&#125;&gt;点击&#123;number&#125;次<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>首先我们会遇到一个<code>eslint-plugin-react-hooks</code>警告<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">React Hook useEffect has a missing dependency: <span class="string">'number'</span>. Either include it or remove the dependency array. (react-hooks/exhaustive-deps)</div></pre></td></tr></table></figure></p><p>而且执行结果也是由于闭包的原因不能正常提交，熟悉useEffect到都知道，这个原因是使用useEffect的时候，依赖需要添加到依赖数组内，这样才能更新数据到useEffect内，但是在这个例子中，添加了依赖后，每次点击都会引起计时器重新执行，引起倒计时失效，就和需求有冲突了，那这种情况下怎么解决呢？</p><p>这个问题其实可以简单归累为：<strong>不想让useEffect重新执行的依赖怎么使用的问题</strong>，这个场景下就只能使用useRef来实现了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> [number, setNumber] = React.useState(<span class="number">0</span>);</div><div class="line">  <span class="keyword">const</span> numberRef = useRef(number);</div><div class="line">  numberRef.current = number;</div><div class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="comment">// do fetch</span></div><div class="line">      <span class="built_in">console</span>.log(numberRef.current);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      clearTimeout(timer);</div><div class="line">    &#125;;</div><div class="line">  &#125;, []);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;button onClick=&#123;() =&gt; setNumber(<span class="function">(<span class="params">c</span>) =&gt;</span> c + <span class="number">1</span>)&#125;&gt;点击&#123;number&#125;次&lt;<span class="regexp">/button&gt;</span></div><div class="line"><span class="regexp">  );</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p><p>通过useRef可以来保证访问到的number一直是最新的，解决了闭包的问题，同时useEffect未直接依赖number，当number变化的时候不会引起重新执行</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>虽然和hooks的写法有关，本质上还是闭包问题，比如forEach内写的定时器也会有同样的问题；但是对于异步场景下的写法，<strong>不想引起useEffect重新执行的变量，就可以用useRef做一层代理</strong>，这种用法只能说是对react hooks设计的<br>一种妥协</p><h2 id="用useCallback肯定能提升性能吗"><a href="#用useCallback肯定能提升性能吗" class="headerlink" title="用useCallback肯定能提升性能吗"></a>用useCallback肯定能提升性能吗</h2><p>useCallback的作用是缓存函数，避免重复生成新函数，引起组件重新渲染，比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Children = <span class="function">(<span class="params">props</span>) =&gt;</span> &lt;button onClick=&#123;props.doFetch&#125;&gt;提交&lt;<span class="regexp">/button&gt;;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">export default function Demo() &#123;</span></div><div class="line"><span class="regexp">  const doFetch = useCallback(() =&gt; &#123;</span></div><div class="line"><span class="regexp">    /</span><span class="regexp">/ fetch();</span></div><div class="line"><span class="regexp">  &#125;, []);</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">  return &lt;Children doFetch=&#123;doFetch&#125; /</span>&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这是一个很常见的写法，但是需要明确在class组件的时候我们通常使用<code>shouldComponentUpdate</code>来拦截更新，通过比较父组件传入的props的变化，来觉得是否re-render子组件，上面的🌰中，<code>&lt;Children /&gt;</code>只是一个普通组件，只对传入的函数包裹一层useCallback是不能起到优化作用的，需要通过包裹一层<code>React.memo</code>才可以，React.memo会对对传入的props进行一次浅比较，避免非必要的更新，如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Children = React.memo(<span class="function">(<span class="params">props</span>) =&gt;</span> &lt;button onClick=&#123;props.doFetch&#125;&gt;提交&lt;<span class="regexp">/button&gt;);</span></div></pre></td></tr></table></figure></p><p>另外需要补充的是，假如有一些特别复杂的对象属性需要传入的话，可以考虑通过useMemo进行一层包裹，避免一些不必要的re-render。当然，使用useMemo也是有一定的性能成本的，假如只是简单计算的话，直接计算就可以了，可能这样的成本还小一些。</p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>下面这个场景下useCallback和React.memo组合可以起到优化的作用吗？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Children = React.memo(<span class="function">(<span class="params">props</span>) =&gt;</span> &lt;button onClick=&#123;props.doSubmit&#125;&gt;提交&lt;<span class="regexp">/button&gt;);</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">export default function Demo() &#123;</span></div><div class="line"><span class="regexp">  const [number, setNumber] = useState(0);</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">  const doSubmit = useCallback(() =&gt; &#123;</span></div><div class="line"><span class="regexp">    console.log(`Number: $&#123;number&#125;`); /</span><span class="regexp">/ 每次输出都是初始值</span></div><div class="line"><span class="regexp">  &#125;, [number]); /</span><span class="regexp">/ 把`text`写在依赖数组里</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">  return (</span></div><div class="line"><span class="regexp">    &lt;&gt;</span></div><div class="line"><span class="regexp">      &lt;input value=&#123;number&#125; onChange=&#123;(e) =&gt; setNumber(e.target.value)&#125; /</span>&gt;</div><div class="line">      &lt;Children doSubmit=&#123;doSubmit&#125; /&gt;</div><div class="line">    &lt;<span class="regexp">/&gt;</span></div><div class="line"><span class="regexp">  );</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p><p>结论是不行，原因可以考虑一下useCallback的deps该怎么处理</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>只需要记得<strong>使用useCallback的时候，对应的子组件一定要使用React.memo包裹</strong>，否则使用useCallback就没有任何的意义。当然useCallback的deps要根据实际场景来添加，否则就不会有任何的优化效果。</p><p>另外对于useCallback，笔者个人的理解是有些破坏代码的可读性了，使用的时候需要按照场景具体评估一下，是否真的需要无脑使用，平衡好代码可维护性和性能</p><h2 id="hooks组件怎么优雅的使用refs"><a href="#hooks组件怎么优雅的使用refs" class="headerlink" title="hooks组件怎么优雅的使用refs"></a>hooks组件怎么优雅的使用refs</h2><p>其实这个问题有些伪命题的感觉，当我们使用在父组件中通过ref操作子组件的方法时，已经就是不优雅的了。官方文档这样说：</p><blockquote><p>在常规的 React 数据流中，props 是父组件与子组件交互的唯一方式。要修改子元素，你需要用新的 props 去重新渲染子元素</p></blockquote><p>只能说非必要的尽量避免直接使用ref吧，尽量避免打乱react的单向数据流。那回到我们的问题，使用hooks的时候如何使用更优雅的使用ref呢</p><p>官方文档提供了以下几个场景刚好适合使用Refs</p><ul><li>处理focus、文本选择或者媒体播放</li><li>触发强制动画</li><li>基层第三方库</li></ul><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>由于函数组件没有实例，在函数组件内不能使用string ref,callback ref, create ref，会有如下报错</p><blockquote><p>Uncaught Invariant Violation: Function components cannot have refs. Did you mean to use React.forwardRef()?</p></blockquote><p>所以在函数组件内是能使用useRef,由于useRef返回一个对象，这个对象只有current一个值，并且这个值的地址在整个组件的生命周期内不会改变，所以useRef提供了组件生命周期内共享数据的存储，修改了ref.current的值不会触发组件re-render，而且组件re-render的时候，ref.current的值也会保留，类似class组件的静态变量，因此我们可以用useRef做很多事情，比如挂载特定的dom或者子组件的实例、存储全局定时器等等</p><p>那useRef怎么使用呢，针对官方问题提供的几个场景，笔者简单给出几个demo</p><h4 id="获取特定dom"><a href="#获取特定dom" class="headerlink" title="获取特定dom"></a>获取特定dom</h4><p>对于原生元素可以直接使用<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Input</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> inputRef = useRef(<span class="literal">null</span>);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    inputRef.current.focus();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;input type=<span class="string">"text"</span> ref=&#123;inputRef&#125; /&gt;</div><div class="line">      &lt;input type=<span class="string">"button"</span> value=<span class="string">"Focus the text input"</span> onClick=&#123;click&#125; /&gt;</div><div class="line">    &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">  );</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p><p>通过ref.current可以直接操作input</p><h3 id="useRef-forwardRef-useImperativeHandle组合用法"><a href="#useRef-forwardRef-useImperativeHandle组合用法" class="headerlink" title="useRef,forwardRef,useImperativeHandle组合用法"></a>useRef,forwardRef,useImperativeHandle组合用法</h3><p>首先先说一下forwardRef</p><blockquote><p>Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧。对于大多数应用中的组件来说，这通常不是必需的。但其对某些组件，尤其是可重用的组件库是很有用的。</p></blockquote><p>简答来说，就是函数式组件要想暴露给父组件ref的时候，需要使用forwardRef才能进行ref的传递。需要明确的是<strong>不能在函数式组件上使用ref属性，因为函数式组件没有实例</strong>，使用的话会直接抛出异常。</p><p>然后再说一下useImperativeHandle，函数式组件使用useImperativeHandle 可以通过 forwardRef 暴露给父组件的自定义方法。这可以类比于class组件，我们可以通过class组件获取ref的组件实例，进而调用内部方法，我们也可以通过useImperativeHandle暴露的方法，调用函数式组件的内部方法，直接看🌰<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; useRef, useImperativeHandle &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</div><div class="line"><span class="keyword">const</span> Children = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> inputRef = useRef(<span class="literal">null</span>);</div><div class="line">  useImperativeHandle(</div><div class="line">    ref,</div><div class="line">    () =&gt; &#123;</div><div class="line">      <span class="keyword">const</span> handleRefs = &#123;</div><div class="line">        onFocus() &#123;</div><div class="line">          inputRef.current.focus();</div><div class="line">        &#125;</div><div class="line">      &#125;;</div><div class="line">      <span class="keyword">return</span> handleRefs;</div><div class="line">    &#125;,</div><div class="line">    []</div><div class="line">  );</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"请输入"</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span>;</span></div><div class="line"><span class="xml">&#125;);</span></div><div class="line"><span class="xml"></span></div><div class="line"><span class="xml">const Demo = () =&gt; &#123;</span></div><div class="line"><span class="xml">  const childRef = useRef(null);</span></div><div class="line"><span class="xml">  const click = () =&gt; &#123;</span></div><div class="line"><span class="xml">    const &#123; onFocus &#125; = childRef.current;</span></div><div class="line"><span class="xml">    onFocus();</span></div><div class="line"><span class="xml">  &#125;;</span></div><div class="line"><span class="xml">  return (</span></div><div class="line"><span class="xml">    <span class="tag">&lt;&gt;</span></span></div><div class="line">      &lt;Children ref=&#123;childRef&#125; /&gt;</div><div class="line">      &lt;button onClick=&#123;click&#125;&gt;输入框focused&lt;/button&gt;</div><div class="line">    &lt;/&gt;</div><div class="line">  );</div><div class="line">&#125;;</div><div class="line"></div><div class="line">export default Demo;</div></pre></td></tr></table></figure></p><p>useImperativeHandle 接受三个参数：</p><ul><li>forWardRef转发过来的ref</li><li>自定义处理函数，返回值时暴露给父组件的ref对象</li><li>依赖项deps，根据实际的依赖传入即可，用于更新ref对象</li></ul><p>通过useImperativeHandle外部组件就可以相对优雅的获取到子组件的“实例”，调用子组件的内部方法</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>写到这里，其实我们也能发现，useRef的使用频率还是挺高的，我们既可以把useRef当成普通的ref的相关API，用来操作子组件，也可以将其作为一个函数式组件内的静态变量来使用，可以说是hooks遇到问题的时候非常万金油的存在了</p><p>说回ref,基本对于函数式组件来说，useRef,forwardRef,useImperativeHandle组合用法能覆盖所有需求了，但是还是那句话，能尽量避免使用的就避免使用，让自己的代码有更高的可维护性</p><h2 id="如何封装自定义hooks"><a href="#如何封装自定义hooks" class="headerlink" title="如何封装自定义hooks"></a>如何封装自定义hooks</h2><p>自定义hooks是基于react hooks api的自定义扩展，可以将一段通用性逻辑封装起来，达到复用的效果; 简单来说通过自定义 Hook，可以将组件逻辑提取到可重用的函数中，可以在组件内直接使用</p><p>封装的自定义hooks一般内部使用多个react hooks，用于解决一些复杂且通用的逻辑。接下来看几个🌰，然后可以对比一下自己的场景，当然也并不是所有能用自定义hooks的地方，就必须要用自定义hooks的，还是要判断一下可复用程度再做决定</p><h3 id="提取自定义-hooks"><a href="#提取自定义-hooks" class="headerlink" title="提取自定义 hooks"></a>提取自定义 hooks</h3><blockquote><p>当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。而组件和 Hook 都是函数，所以也同样适用这种方式。</p></blockquote><p>自定义 hooks 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。自定义hooks和普通的函数并没有任何不同，但是结合公共hooks API的能力，在react的调度下，我们可以实现很多很有趣的功能，社区有实现的<a href="https://github.com/alibaba/hooks?spm=ata.21736010.0.0.1b261134fcWTYx" target="_blank" rel="external">ahooks</a>自定义hooks库，也可以自己参考一下</p><p>接下来简单放几个相对有代表性的🌰：</p><h3 id="useState属性合并"><a href="#useState属性合并" class="headerlink" title="useState属性合并"></a>useState属性合并</h3><p>你的代码里是不是写过这样的代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [duration, setDuration] = useState(<span class="number">0</span>);</div><div class="line"><span class="keyword">const</span> [currentTime, setCurrentTime] = useState(<span class="number">0</span>);</div><div class="line"><span class="keyword">const</span> [volume, setCurrent] = useState(<span class="number">0</span>);</div><div class="line"><span class="keyword">const</span> [speed, setSpeed] = useState(<span class="number">0</span>);</div><div class="line">...</div></pre></td></tr></table></figure></p><p>这段代码是之前封装播放器的一段代码，里面对video的属性进行一定的提取，导致了代码中一排蔚为壮观的useState,这样的写法其实可以优化到一个字段内<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [player, setPlayer] = useState(&#123;</div><div class="line">  duration: <span class="number">0</span>,</div><div class="line">  currentTime: <span class="number">0</span>,</div><div class="line">  volume: <span class="number">0</span>,</div><div class="line">  speed: <span class="number">0</span>,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>当然这个时候更新装状态需要带上旧的状态<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setPlayer(&#123;...player, duration&#125;);</div></pre></td></tr></table></figure></p><p>那怎么才能再省点代码，让我可以直接修改需要修改的参数，不需要改变的依旧保持现状呢，这个时候就可以封装一个自定义hooks，如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> useMergeState = <span class="function">(<span class="params">initialState</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> [state, setState] = useState(initialState);</div><div class="line">  <span class="keyword">const</span> setMergeState = <span class="function">(<span class="params">pickState</span>) =&gt;</span> &#123;</div><div class="line">    setState(<span class="function"><span class="params">preState</span> =&gt;</span> &#123;...preState, &#123;...pickState&#125;&#125;);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> [state, setMergeState]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样就可以直接使用了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [player, setPlayer] = useMergeState(&#123;</div><div class="line">  duration: <span class="number">0</span>,</div><div class="line">  currentTime: <span class="number">0</span>,</div><div class="line">  volume: <span class="number">0</span>,</div><div class="line">  speed: <span class="number">0</span>,</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setPlayer(&#123; <span class="attr">duration</span>: <span class="number">2</span>&#125;);</div></pre></td></tr></table></figure></p><p>这就是一个最简单的自定义hooks，当然useMergeState还有可优化的地方，比如参考useState的用法，pickState可能是个函数，需要判断一下入参类型；然后内部的实现setMergeState其实可以通过useCallback进行一下包裹，让函数不用每次都初始化等等</p><h3 id="dom相关的hooks"><a href="#dom相关的hooks" class="headerlink" title="dom相关的hooks"></a>dom相关的hooks</h3><p>我们经常会监听dom的滚动来做一些自定义的逻辑，比如滚动翻页等等，一个监听滚动的自定义hooks该怎么实现呢，我们需要先确定我们需获取到哪些值，以及我们的入参数是什么</p><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>入参：毋庸置疑肯定是dom元素的引用，可以使用useRef来实现<br>返回值：一般都是元素滚动的高度，可以根据自己的实际来决定</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> useScroll = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> [position, setPosition] = useState();</div><div class="line"></div><div class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onscroll</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">      setPos([target.current.scrollLeft, target.current.scrollTop])</div><div class="line">    &#125;</div><div class="line">    target.current.addEventListener(<span class="string">'scroll'</span>, onscroll, <span class="literal">false</span>)</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      target.current.removeEventListener(<span class="string">'scroll'</span>, onscroll, <span class="literal">false</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;, [])</div><div class="line"></div><div class="line">  <span class="keyword">return</span> position</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> useScroll</div></pre></td></tr></table></figure><p>上述代码也是有一些可以优化的地方，比如一些参数有效性的判断等，这个🌰只是一个演示，提供一个参考思路</p><h3 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h3><p>防抖节流函数大家肯定经常在开发中遇到，面试的估计也没有被少问。一般都是我们避免频繁调用接口，或者在react中避免频繁改动state的时候需要使用的，防抖节流的区别这里也不赘述了，简单来说主要区别就是防抖是操作后n秒内只能调用一次，假如n秒内又触发了操作，重新倒计时n秒；节流就是操作n秒内只能调用一次，即使是多次触发操作也是n秒内执行一次；节流一般用在输入框搜索，需要在最后一次提交后触发；节流一般用在滚动监听等等。</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; useEffect, useMemo &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> debounce <span class="keyword">from</span> <span class="string">'lodash/debounce'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> useDebounce = <span class="function">(<span class="params">fn, wait</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> wait = wait ?? <span class="number">1000</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> debounced = useMemo(</div><div class="line">      () =&gt;</div><div class="line">        debounce(</div><div class="line">          fn(),</div><div class="line">          wait</div><div class="line">        ),</div><div class="line">      [],</div><div class="line">  );</div><div class="line">  <span class="keyword">return</span> [debounced.run, debounced.cancel];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述代码为了突出自定义hooks的用法，基于lodash/debounce实现了一个节流hooks，其实核心就是简化debounce的用法，当然lodash/debounce还有更多的配置，自己可以基于自己的实际场景进行封装</p><p>至于节流函数就作为一个思考题可以自己实现一下</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>自定义hooks可以维护在项目中的一个单独hooks文件夹内，作为全局公共方法提供，当然也可以发布到自己的npm组件，提供给更多的项目使用。还有跟多的用法就不再一一演示了，可以自己实现一些，已加深对自定义hooks的理解</p><h2 id="React-V18新增了哪些hooks-API"><a href="#React-V18新增了哪些hooks-API" class="headerlink" title="React V18新增了哪些hooks API"></a>React V18新增了哪些hooks API</h2><p>React V18已经发布了一段时间了，针对hooks也提供了一些新的API。新增的API有<code>useId，useInsertionEffect，useTransition，useDeferredValue，useSyncExternalStore</code>，让我们一一看看提供了什么新的能力。</p><h3 id="Before，先看看React-V18带来了什么"><a href="#Before，先看看React-V18带来了什么" class="headerlink" title="Before，先看看React V18带来了什么"></a>Before，先看看React V18带来了什么</h3><p>可以可选的开启 Concurrent Mode，大幅提高了React的性能，推出了时间切片和任务优先级的概念，让 React 有了更多的可能性，更多的描述可以去看看官方文档，我们关注的点还是这几个新增的hooks，让我们简单的了解一下这几个API，具体的使用方法可以自己尝试一下</p><h3 id="useSyncExternalStore"><a href="#useSyncExternalStore" class="headerlink" title="useSyncExternalStore"></a>useSyncExternalStore</h3><p>顾名思义，这个API是针对React的第三方状态管理库的。由于V18可以开启concurrent mode,使得render这个过程能够切分成以fiber为最小单位的多次任务,这些任务可能就会存在对外部状态的修改，加入在render的任务分片前后部分状态被修改了，那就会造成多次渲染结果不一致的问题，也就是<strong>tearing 问题</strong>，tearing 通俗地讲，就是外部状态不受 react 异步调度控制，非常容易错乱。useSyncExternalStore就是防止tearing的出现，通过订阅的方式保持最终渲染结果的一致性。</p><p>最后简单看看API<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">useSyncExternalStore(</div><div class="line">    subscribe, <span class="comment">// 接收一个subscribe函数，该函数接收一个函数用于通知react外部状态发生变更</span></div><div class="line">    getSnapshot, <span class="comment">// 返回外部状态的最新快照值</span></div><div class="line">)</div></pre></td></tr></table></figure></p><h3 id="useTransition"><a href="#useTransition" class="headerlink" title="useTransition"></a>useTransition</h3><p>transition 特性也是依赖 concurrent mode的，可以用来降低渲染优先级。当我们用startTransition包裹计算量大的函数的时候，就相当于通知了React当前计算的优先级很低，可以降低更新的优先级，减少重复渲染次数，可以当成一个防抖函数来处理（不完全相同）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Demo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> [isPending, startTransition] = useTransition();</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">      &lt;input</div><div class="line">        type=<span class="string">"text"</span></div><div class="line">        onChange=&#123;(event) =&gt; &#123;</div><div class="line">          startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(event.target.value);</div><div class="line">        &#125;&#125;&#125;</div><div class="line">      /&gt;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看看官方的这个<a href="https://codesandbox.io/s/sparkling-field-41z4r3" target="_blank" rel="external">demo</a></p><h3 id="useDeferredValue"><a href="#useDeferredValue" class="headerlink" title="useDeferredValue"></a>useDeferredValue</h3><p>和useTransition类似，useDeferredValue的特性也是依赖 concurrent mode 的, 可以直接翻译为使用一个推迟的值。 useDeferredValue 可以让我们延迟渲染优先级不高的部分，等高优先级的渲染任务结束后，延迟的渲染才开始，并且可中断不会阻塞用户输入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Demo = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// React 将会在合适的时间生成deferredValue</span></div><div class="line">  <span class="keyword">const</span> deferredValue = useDeferredValue(value, &#123; <span class="attr">timeoutMs</span>: <span class="number">1000</span> &#125;);</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div&gt;</div><div class="line">      &#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">        deferredValue</div><div class="line">      &#125;</div><div class="line">    &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">  );</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure><h3 id="useInsertionEffect"><a href="#useInsertionEffect" class="headerlink" title="useInsertionEffect"></a>useInsertionEffect</h3><p>类似useLayoutEffect，区别就是不能访问dom</p><p>useInsertionEffect的出现就是为了解决cssinjs问题的，用于插入样式规则，而且一般是插入全局DOM节点，比如<code>&lt;style/&gt;</code>等。这个hooks为了避免在concurrent mode下，客户端生成或编辑<code>&lt;style/&gt;</code>时引起性能问题，可以在这个hooks中操作插入一些css节点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCSS</span>(<span class="params">rule</span>) </span>&#123;</div><div class="line">  useInsertionEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">document</span>.head.appendChild(rule);</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> rule;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> Demo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> className = useCSS(rule);</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span> /&gt;</span>;</span></div><div class="line"><span class="xml">&#125;</span></div></pre></td></tr></table></figure></p><h3 id="useID"><a href="#useID" class="headerlink" title="useID"></a>useID</h3><p>一般用于服务端渲染，生成一个ID，但是不要把这个ID作为数组循环渲染的key，渲染的唯一key一般是从你的数据中生成的, 就不再详细介绍了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>React Hooks很好用，但是想用好，还是需要多一点思考的。框架提供的能力，想转换为实际的生产力就需要我们不停的去学习如何使用这些能力，不断总结，有问题可以留言交流</p><p><strong>参考资料</strong></p><p><a href="https://react.html.cn/docs/refs-and-the-dom.html" target="_blank" rel="external">Refs 和 DOM官方文档</a><br><a href="https://zh-hans.reactjs.org/docs/hooks-custom.html" target="_blank" rel="external">自定义 Hook</a><br><a href="https://www.zhihu.com/question/502917860" target="_blank" rel="external">如何理解 React 18 中的 useSyncExternalStore ?</a><br><a href="https://blog.shabby.in/how-to-use-useTransition/useDerferredValue/" target="_blank" rel="external">useTransition/useDerferredValue使用指南</a></p><p><img src="http://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;杭州下雪了，想去西湖看雪了，雪后的杭州更有水墨画里的感觉了，一下雪杭州就成了临安&lt;/p&gt;
&lt;p&gt;今天主要想说一下react hooks，react hooks是react v16.8 之后引入的API，现在react都已经到18了，hooks怎么还能不会用呢。hooks引入的目的是给函数式组件增加数据状态管理的能力，同时增加代码的可复用能力。但是同时hooks也是一个潘多拉魔盒，因为函数式组件不再只是单纯的一个纯函数了，可以在内部处理副作用了，使用不好就会经常遇到各种各样的问题，而且错误的使用方式也会引起re-render，引起一些性能上的问题&lt;/p&gt;
&lt;p&gt;本文主要介绍hooks的常见的几个问题与最优实践，同时介绍一下随着react版本迭代的API的变化&lt;/p&gt;
&lt;p&gt;闲言少叙，直接进入正文&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="https://zhyjor.github.io/categories/React/"/>
    
    
      <category term="js" scheme="https://zhyjor.github.io/tags/js/"/>
    
      <category term="React" scheme="https://zhyjor.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>我是如何从eggjs升级到midwayjs的</title>
    <link href="https://zhyjor.github.io/2022/11/25/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E4%BB%8Eeggjs%E5%8D%87%E7%BA%A7%E5%88%B0midwayjs%E7%9A%84/"/>
    <id>https://zhyjor.github.io/2022/11/25/我是如何从eggjs升级到midwayjs的/</id>
    <published>2022-11-25T06:46:47.000Z</published>
    <updated>2023-10-11T02:22:23.804Z</updated>
    
    <content type="html"><![CDATA[<p>今天突然发现园区的银杏叶突然全黄了，想起来两周前到临安去玩的时候还是青黄交加的一片呢。虽然最近温度似乎也没怎么降，但从最近路边的落叶上看，真的是深秋了，可能就再需要一场秋雨，杭州就要开始入冬了吧</p><p>最近笔者在维护一个旧的node项目，项目基于eggjs开发的，数据库是mysql，缓存redis，消息中间件用的是rocketMQ。项目早期用的是js，在改造typescript的过程中，越来越感觉到eggjs对typescript兼容性不好，加上midwayjs的Ioc机制是开发中的一个爽点，还是决定畅通不如短痛，升级midwayjs</p><a id="more"></a><h2 id="midwayjs简介"><a href="#midwayjs简介" class="headerlink" title="midwayjs简介"></a>midwayjs简介</h2><p>先放<a href="https://midwayjs.org/docs/intro" target="_blank" rel="external">官方文档</a>传送门</p><blockquote><p>Midway 是阿里巴巴 - 淘宝前端架构团队，基于渐进式理念研发的 Node.js 框架，通过自研的依赖注入容器，搭配各种上层模块，组合出适用于不同场景的解决方案</p></blockquote><p>先看看关键字，<strong>依赖注入</strong>，对于前端同学来说，这是个相对陌生的点。也难怪，日常开发中这些使用的确实不多，java同学会了解的相对多一点，毕竟IoC能力是Java Spring 体系中非常重要的核心，而这也是MidWay的核心竞争力了。另外Midway全量使用TypeScript，结合TS装饰器，让开发体验有质的提升。项目使用中类型推导很好用，这对日常维护能起到非常正面的作用。下面是一个简单的🌰<br>·</p><h3 id="为什么不是nestjs"><a href="#为什么不是nestjs" class="headerlink" title="为什么不是nestjs"></a>为什么不是nestjs</h3><p>社区内还有类似的<a href="https://docs.nestjs.com/" target="_blank" rel="external">nestjs框架</a>，两者都是走的IoC方式，两者都是框架的封装（midwayjs–&gt;eggjs–&gt;koajs,nestjs–&gt;express.js，当然midwayjs支持切换依赖的web框架），提供一些开发中过于模版化的能力，简化日常开发中的配置复杂度，让你更能专注于业务，两者并没有什么本质上的区别。midwayjs是阿里的团队开源的，nestjs是国外Trilon团队的，性能上没有做对比，应该也不会有太大的差异，没必要太纠结具体去用哪个框架</p><p>所以笔者并不太在意到底用什么框架，但是团队内的同学更熟悉eggjs，eggjs到midwayjs的学习曲线相对平滑，而且midway的文档更友好一些，基于后续维护成本的考虑，在体验并没有打折的情况下，就选定了midwayjs了</p><p>接下来先看看IoC机制，以及Typescript装饰器是什么</p><h2 id="IoC机制"><a href="#IoC机制" class="headerlink" title="IoC机制"></a>IoC机制</h2><p>IoC（Inversion of Control）即是“控制反转”，这并非是一种技术，是面向对象编程的一种设计思想。在Java中，IoC意味着你将设计好的对象交给容器控制，而不是在对象内直接控制，理论很抽象，看个🌰<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p><h2 id="Typescript装饰器"><a href="#Typescript装饰器" class="headerlink" title="Typescript装饰器"></a>Typescript装饰器</h2><p><strong>参考资料</strong><br><a href="https://developer.aliyun.com/article/680405" target="_blank" rel="external">控制反转（IOC）和依赖注入（DI）的关系</a></p><p><img src="https://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天突然发现园区的银杏叶突然全黄了，想起来两周前到临安去玩的时候还是青黄交加的一片呢。虽然最近温度似乎也没怎么降，但从最近路边的落叶上看，真的是深秋了，可能就再需要一场秋雨，杭州就要开始入冬了吧&lt;/p&gt;
&lt;p&gt;最近笔者在维护一个旧的node项目，项目基于eggjs开发的，数据库是mysql，缓存redis，消息中间件用的是rocketMQ。项目早期用的是js，在改造typescript的过程中，越来越感觉到eggjs对typescript兼容性不好，加上midwayjs的Ioc机制是开发中的一个爽点，还是决定畅通不如短痛，升级midwayjs&lt;/p&gt;
    
    </summary>
    
      <category term="node" scheme="https://zhyjor.github.io/categories/node/"/>
    
    
      <category term="nodejs,eggjs,midwayjs,前端" scheme="https://zhyjor.github.io/tags/nodejs-eggjs-midwayjs-%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Ant Design 5.0 正式发布了，你要升级吗</title>
    <link href="https://zhyjor.github.io/2022/11/18/AntDesign5-0%E7%89%88%E6%9C%AC%E6%9D%A5%E4%BA%86/"/>
    <id>https://zhyjor.github.io/2022/11/18/AntDesign5-0版本来了/</id>
    <published>2022-11-18T06:31:46.000Z</published>
    <updated>2023-10-11T02:22:23.788Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.zhyjor.com/blog/4E72CEF8-10AB-408C-8E33-80DE5399B6A3.png" alt=""><br>周五了，这周忙里偷闲去了两天桐庐，淡季加上工作日，人好少。而且作为一个标准的江南小城，山青水秀，慢生活的基调就会让人整个松弛下来，即使就简单的在酒店附近走走，就已经是很舒服了。</p><p>好了，闲话少说，今天antd正式发布了5.0版本，笔者是antd重度用户，公司的B端业务组件就是基于antd定制开发的，在5.0发布之前，也在一直在关注beta版本，让我们一起看看5.0在技术上引入了什么新的变化吧</p><a id="more"></a><p>本文不对设计的变化做评价，仅在技术选型、工程化等技术角度进行分析</p><h2 id="css-in-js"><a href="#css-in-js" class="headerlink" title="css-in-js"></a>css-in-js</h2><p>antd动态主题使用了css-in-js方案，抛弃了一直以来的less，放弃了css variables能力，这算是5.0引入的最大变化了，说到css-in-js旧不得不说最近关于css-in-js的一些争议</p><h3 id="css-in-js争议"><a href="#css-in-js争议" class="headerlink" title="css-in-js争议"></a>css-in-js争议</h3><p>最近由于Sam的那篇<a href="https://dev.to/srmagura/why-were-breaking-up-wiht-css-in-js-4g9b" target="_blank" rel="external">Why We’re Breaking Up with CSS-in-JS</a>，直接将css-in-js推到了风口浪尖上，其实这个时候发布了强依赖css-in-js的5.0多少有些尴尬，官方也没有对这个问题进行过多的说明，只是复述了一下使用场景</p><p>归根结底，还是Sam这篇文章写的太客观，作为<a href="https://emotion.sh/docs/introduction" target="_blank" rel="external">Emotion</a>主要开发者，对css-in-js的有着更深的理解，很客观的说明了方案的优缺点，最后抛出弃用css-in-js最核心的原因：性能问题，这一点是无解的，css-in-js需要在react重渲染组件时序列化className，这就不可避免地带来运行时的性能损失</p><p>目前作者使用的方案是css module，除了在css中直接使用js变量需要特定的方式兼容外，其他css-in-js提供的有点，都可以直接兼容，并且没有性能的损失，这应该就是作者弃用css-in-js的核心原因了</p><h3 id="ant-design-5-0用css-in-js做了什么"><a href="#ant-design-5-0用css-in-js做了什么" class="headerlink" title="ant design 5.0用css-in-js做了什么"></a>ant design 5.0用css-in-js做了什么</h3><p>对于动态定制主题而言，关键也是在于如何在性能和维护成本之间做取舍，css-in-js方案可以直接在样式中使用js变量，这对定制主题而言确实可以省掉一些模版代码。and design 5.0使用了<a href="https://github.com/ant-design/cssinjs" target="_blank" rel="external">@ant-design/cssinjs</a>作为自己的css-in-js方案，打开文档去看看，官方说法也很明确</p><blockquote><p>It’s a subset of Emotion with design token logic wrapper.<br>是基于<code>Emotion</code>定制了一部分能力的，直接依赖了<code>@emotion/hash</code>, <code>@emotion/unitless</code>，文档上也直接推荐使用<code>Emotion</code>，而<code>@ant-design/cssinjs</code>通过牺牲动态性来获取更高的缓存效率，从而减少运行时的性能损耗，<code>@ant-design/cssinjs</code>提供的DerivativeToken能力也是这一版本一个亮点，可以简化一些动态主题的配置，会在下一节进行介绍</p></blockquote><p>另外使用了css-in-js后，天然支持TreeShaking，不需要再配置插件了</p><h2 id="Design-Token"><a href="#Design-Token" class="headerlink" title="Design Token"></a>Design Token</h2><p>在ant design v4版本是，笔者经历的使用antd的ToB项目中，很多是需要主题定制的,需要动态主题的地方目前主要还是定义css变量的方式，比如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">color</span>: <span class="selector-tag">var</span>(<span class="selector-tag">--color</span>);</div></pre></td></tr></table></figure></p><p>通过将<code>--color</code>挂在到<code>:root</code>的方式，进行动态主题配置，在v5版本的介绍中，通过Design Token 模型可以派生出几乎所有需要定制的颜色、间距、大小等。且利用上文提到的css-in-js方案，也不再需要和v4一样定义一堆挂在到<code>:root</code>上的变量了，确实简化了很多动态主题的配置，这里贴上一张官方的配图<br><img src="https://static.zhyjor.com/blog/4434FCF4-3AF1-4D3E-846C-B7A5E4027DC7.png" alt=""></p><p>除了整体的可定制，各个组件也可以通过外层的配置来实现样式定制能力,这里就贴一下官方的demo<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;ConfigProvider</div><div class="line">    theme=&#123;&#123;</div><div class="line">      components: &#123;</div><div class="line">        Radio: &#123;</div><div class="line">          colorPrimary: <span class="string">'#00b96b'</span>,</div><div class="line">        &#125;,</div><div class="line">      &#125;,</div><div class="line">    &#125;&#125;</div><div class="line">  &gt;</div><div class="line">    &lt;Radio&gt;Radio&lt;<span class="regexp">/Radio&gt;</span></div><div class="line"><span class="regexp">    &lt;Checkbox&gt;Checkbox&lt;/</span>Checkbox&gt;</div><div class="line">  &lt;<span class="regexp">/ConfigProvider&gt;</span></div></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为antd的深度用户，笔者也会慢慢将自己基于antd的内部组件库慢慢开始升级，目前来看相对痛点的就是自定义主题的升级，因为很难复用旧的逻辑，这点需要先利用v5的能力，保留旧的方案，慢慢替换为design token的方式；另外，还是需要观察一下css-in-js的性能，虽然是B端项目，用户体验上也是不能打折。</p><p><strong>参考资料</strong><br><a href="https://mp.weixin.qq.com/s/qL7UMdHicrk-4b1vYVSIWQ" target="_blank" rel="external">Ant Design 5.0 正式发布</a></p><p><img src="https://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://static.zhyjor.com/blog/4E72CEF8-10AB-408C-8E33-80DE5399B6A3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;周五了，这周忙里偷闲去了两天桐庐，淡季加上工作日，人好少。而且作为一个标准的江南小城，山青水秀，慢生活的基调就会让人整个松弛下来，即使就简单的在酒店附近走走，就已经是很舒服了。&lt;/p&gt;
&lt;p&gt;好了，闲话少说，今天antd正式发布了5.0版本，笔者是antd重度用户，公司的B端业务组件就是基于antd定制开发的，在5.0发布之前，也在一直在关注beta版本，让我们一起看看5.0在技术上引入了什么新的变化吧&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://zhyjor.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://zhyjor.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>用状态机做一个云构建平台</title>
    <link href="https://zhyjor.github.io/2022/11/12/%E7%94%A8%E7%8A%B6%E6%80%81%E6%9C%BA%E5%81%9A%E4%B8%80%E4%B8%AA%E4%BA%91%E6%9E%84%E5%BB%BA%E5%B9%B3%E5%8F%B0/"/>
    <id>https://zhyjor.github.io/2022/11/12/用状态机做一个云构建平台/</id>
    <published>2022-11-12T02:50:40.000Z</published>
    <updated>2023-10-11T02:22:23.808Z</updated>
    
    <content type="html"><![CDATA[<p>最近在升级团队云构建的工具，由于构建任务的状态跳转很复杂，早期的IF-ELSE写法已经无法满足任务管理的扩展了，比如我想加一个代码规则的校验，那我就需要加上新的条件分支，各种IF-ELSE散落到各种异步逻辑中，这就给后续产品逻辑调整继续增加负担，因此决定用状态机来描述构建任务的流转，让逻辑变得可预测。</p><p>本文的重点是介绍用状态机描述一个云构建任务的流转，具体的构建方式可以根据自己团队的实际情况来设计</p><p>闲言少叙，开始<br><a id="more"></a></p><h2 id="云构建是什么"><a href="#云构建是什么" class="headerlink" title="云构建是什么"></a>云构建是什么</h2><p>顾名思义，就是在服务端进行代码的build。体现在前端就是通过在云端提供的node环境上，运行打包工具，将源代码构建成浏览器可执行的代码，并将打包物返回给调用方的方式<br>目前很多在用的travis、gitlab-ci都是一种云构建的工具，通过简单的配置的就可以进行自动化的构建，比如博主在构建github page时，在github上用到的travis的配置如下：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ʹ������</span></div><div class="line"><span class="attr">language:</span> <span class="string">node_js</span></div><div class="line"><span class="attr">node_js:</span> <span class="string">"10"</span></div><div class="line"><span class="attr">branches:</span></div><div class="line"><span class="attr">  only:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">master</span></div><div class="line"><span class="attr">cache:</span></div><div class="line"><span class="attr">  apt:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  yarn:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  directories:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">node_modules</span></div><div class="line"><span class="attr">before_install:</span></div><div class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="bullet">--global</span> <span class="string">user.name</span> <span class="string">"xxx"</span></div><div class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="bullet">--global</span> <span class="string">user.email</span> <span class="string">"xxx@xxx.com"</span></div><div class="line"><span class="bullet">-</span> <span class="string">curl</span> <span class="bullet">-o-</span> <span class="bullet">-L</span> <span class="attr">https://yarnpkg.com/install.sh</span> <span class="string">| bash</span></div><div class="line"><span class="string">- export PATH=$HOME/.yarn/bin:$PATH</span></div><div class="line"><span class="string">- npm install -g hexo-cli</span></div><div class="line"><span class="string"></span><span class="attr">install:</span></div><div class="line"><span class="bullet">-</span> <span class="string">yarn</span></div><div class="line"><span class="attr">script:</span></div><div class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></div><div class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span></div><div class="line"><span class="attr">after_success:</span></div><div class="line"><span class="bullet">-</span> <span class="string">cd</span> <span class="string">./public</span></div><div class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">init</span></div><div class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="bullet">--all</span> <span class="string">.</span></div><div class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"Travis CI Auto Builder"</span></div><div class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">--quiet</span> <span class="bullet">--force</span> <span class="attr">https://$REPO_TOKEN@github.com/zhyjor/zhyjor.github.io</span></div><div class="line">  <span class="string">master</span></div></pre></td></tr></table></figure></p><p>gitlab ci上配置也差不多，这样云端的构建基本就完成了；自己的项目中完全可以在success后，将构建物推到cdn上，然后通过cms工具发布一下html即可，这样一个简单的云构建流程就起来了</p><h3 id="为什么需要云构建呢"><a href="#为什么需要云构建呢" class="headerlink" title="为什么需要云构建呢"></a>为什么需要云构建呢</h3><p>博主之前遇到多次由于打包环境不一致引发的线上问题，引起环境不一致的可能是node版本不一致引发的问题，也可能是构建时代码未进行pull造成功能缺失等等，总结下有一下几点</p><ul><li>提供纯净的无干扰的环境，避免本地环境不同（node、os等），引起构建物的差异</li><li>提供可溯源的管控平台，可对项目发布进行管理</li><li>避免代码未提交引起线上分支功能缺失问题</li><li>记录构建日志、构建时长、分析依赖，未项目优化提供数据支持</li></ul><h2 id="状态机是什么"><a href="#状态机是什么" class="headerlink" title="状态机是什么"></a>状态机是什么</h2><p>前端场景下说到状态机，就不可避免的谈到状态管理，使用vue全局状态管理一般是vuex，react一般是Redux。UI=Fx(Data),使用了这些框架后，前端写的大部分业务逻辑都是在管理状态，然后框架帮我吗映射为UI</p><p>随着业务的逐渐膨胀，业务逻辑层（数据层）逐渐变成了一团逐渐失控的代码，状态，由于本文重点不是讨论状态管理框架的，这里贴一张克军大佬的ppt，很明确的表现了复杂逻辑下，状态失控的问题</p><p><img src="https://static.zhyjor.com/blog/A24699C3-6877-467B-AC14-CEC29C2830E5.png" alt=""></p><p>复杂的业务逻辑带来的是太多的逻辑分支，各种IF-ELSE分散在不同的组件内，造成代码难阅读，难扩展</p><h3 id="使用状态的好处"><a href="#使用状态的好处" class="headerlink" title="使用状态的好处"></a>使用状态的好处</h3><p>有限状态机，是表示多个有限状态以及这些状态间的转移、动作的数学模型，通过构建这个数学模型，将业务逻辑描述出来；通俗来说，状态机的描述文件就是一个剧本，通过这个剧本，逻辑就变得可预测了</p><p><img src="https://static.zhyjor.com/blog/CC33525C-D52F-4932-9428-C942CD9FD778.png" alt=""></p><h3 id="XState"><a href="#XState" class="headerlink" title="XState"></a>XState</h3><p>我们选择了XState作为云构建的状态机框架，状态机的库也挺多的，XState、JavaScript-State-Machine、Robot等，XState的优势是文档更好，同时具有可视化工具，使用VSCode的扩展可以很方便的进行状态机设计</p><h2 id="状态机设计"><a href="#状态机设计" class="headerlink" title="状态机设计"></a>状态机设计</h2><p>状态机设计这里社区没什么最优实践，也没什么明确的方法论，只能结合自己的业务逻辑给出一个适合自己的方案</p><h3 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h3><p>一个云构建任务分为如下的几个过程，其中check阶段作为并行任务实现<br><img src="https://static.zhyjor.com/blog/EE43F775-7DF5-4934-9DC2-2F86237A1048.png" alt=""></p><p>由上图可得出状态机的简单描述文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createMachine, interpret, assign &#125; <span class="keyword">from</span> <span class="string">'xstate'</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">startAsyncTask</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      resolve(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> buildMachine =</div><div class="line">  <span class="comment">/** @xstate-layout N4IgpgJg5mDOIC5QCMCuBLANhAdOimYAxAAoBKAoiQIKUD6FAcgGoDaADALqKgAOA9rHQAXdPwB2PEAA9EARgDMcnO1WqATAE45ADl3qdAdgA0IAJ6J1AFnU5DmvQFYdVw1Z3tNhnQF8fptCxcCH4AYwBrMAAnIhDxMDxxADd+SJxYYQBDKOEAYQks9Hiojm4kEAEhUQkpWQQrR00cBU12ADY5dS7FDp1TCwR1BQUcLzbHKwUrTq05Nr8AjGwcEIjoomio-iicXkxM4QAzbYBbdKyc-PFC4tKpSpExSXK6hqaW9pn1Ht1++SnRpogZoFIZQZour5-CBAstQpgJMQ4gkiik0lARLkEfE7uUHtVnqA6jpQYDvo42oZHHNXJo-oNHIYcFY2u45A57FMjAsYUtcLCILFEYk0QksrBwgAhPm4viCR41F7yORUnA6AzsHTOdiOdgqkzmSyM5msvQckHuQw8gW7VDITDoWAACyF8RFqQSvDtDudABV+LkIOJZRV5QTavJqUzXOMddYdBCFG16epjSy2eauVboTbDpksKgosRKL6yABNEP4p4RhAUxzNNwOdkJ9RtbT09WA4FtsZtdUKPzQ8T8CBwKQ2-CEe5h6tK+rqFMAzSmuaswxDBMDnN8lZhSJRadVWdEyzLnAGVqNORyaYKPqGwbs89N9dtJQKdTsUHWnfwxGHhVCRkRBKSsNVWjaL9WSsGxpkXEZl3cdpE3UNx2GzRYghwAUAPDOc5D1WxX0cD820MewrHg0ZTSmL9nEaVCfywr17UdJ1cOPYCEEUCYGysTRHG+aYezpB8hgQmirDorUIQw3ksNgVBQlCOB4DxGdFRPbj1yaIx+ME-jVAhFM01NLRtG8Dp1CY5Y8wLIsOM0rjQPA9ooJg2C5HpORBOZHR1RcRQtAmOYbIgRygLqABaZMHxilQ1EUTxIR1KxBx8IA */</span></div><div class="line">  createMachine(&#123;</div><div class="line">    context: &#123;</div><div class="line">      id: <span class="number">42</span>,</div><div class="line">      repo_url: <span class="literal">undefined</span>,</div><div class="line">      recordTime: &#123;</div><div class="line">        docker: &#123; <span class="attr">start</span>: <span class="literal">undefined</span>, <span class="attr">end</span>: <span class="literal">undefined</span> &#125;,</div><div class="line">        clone: &#123; <span class="attr">start</span>: <span class="literal">undefined</span>, <span class="attr">end</span>: <span class="literal">undefined</span> &#125;,</div><div class="line">        install: &#123; <span class="attr">start</span>: <span class="literal">undefined</span>, <span class="attr">end</span>: <span class="literal">undefined</span> &#125;,</div><div class="line">        build: &#123; <span class="attr">start</span>: <span class="literal">undefined</span>, <span class="attr">end</span>: <span class="literal">undefined</span> &#125;,</div><div class="line">      &#125;,</div><div class="line">      imageUrl: <span class="string">"node:16"</span>,</div><div class="line">    &#125;,</div><div class="line">    id: <span class="string">"build"</span>,</div><div class="line">    initial: <span class="string">"idle"</span>,</div><div class="line">    states: &#123;</div><div class="line">      idle: &#123;</div><div class="line">        on: &#123;</div><div class="line">          PREPARE_ENV: &#123;</div><div class="line">            target: <span class="string">"docker"</span>,</div><div class="line">          &#125;,</div><div class="line">        &#125;,</div><div class="line">      &#125;,</div><div class="line">      docker: &#123;</div><div class="line">        invoke: &#123;</div><div class="line">          id: <span class="string">"startContainer"</span>,</div><div class="line">          src: <span class="function">(<span class="params">context, event</span>) =&gt;</span> &#123;</div><div class="line">            <span class="comment">// 更新一下一下时间</span></div><div class="line">            <span class="keyword">const</span> dockerTimeStart = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</div><div class="line">            <span class="keyword">const</span> dockerTime = context.recordTime.docker;</div><div class="line">            dockerTime.start = dockerTimeStart;</div><div class="line">            context.recordTime.docker = dockerTime;</div><div class="line">            assign(&#123; <span class="attr">recordTime</span>: &#123; ...context.recordTime &#125; &#125;);</div><div class="line">            <span class="comment">// image start</span></div><div class="line">            <span class="keyword">return</span> startAsyncTask(context.imageUrl);</div><div class="line">          &#125;,</div><div class="line">          onDone: [</div><div class="line">            &#123;</div><div class="line">              target: <span class="string">"clone"</span>,</div><div class="line">              actions: assign(&#123;</div><div class="line">                recordTime: <span class="function">(<span class="params">context, event</span>) =&gt;</span> &#123;</div><div class="line">                  <span class="keyword">const</span> dockerTime = context.recordTime.docker;</div><div class="line">                  dockerTime.end = event.data;</div><div class="line">                  context.recordTime.docker = dockerTime;</div><div class="line">                  <span class="keyword">return</span> context.recordTime;</div><div class="line">                &#125;</div><div class="line">              &#125;),</div><div class="line">            &#125;,</div><div class="line">          ],</div><div class="line">          onError: [</div><div class="line">            &#123;</div><div class="line">              target: <span class="string">"failure"</span>,</div><div class="line">              actions: assign(&#123; <span class="attr">error</span>: <span class="function">(<span class="params">context, event</span>) =&gt;</span> event.data &#125;),</div><div class="line">            &#125;,</div><div class="line">          ],</div><div class="line">        &#125;,</div><div class="line">      &#125;,</div><div class="line">      clone: &#123;</div><div class="line">        invoke: &#123;</div><div class="line">          src: <span class="function">(<span class="params">context, event</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> startAsyncTask(context.repo_url);</div><div class="line">          &#125;,</div><div class="line">          id: <span class="string">"gitClone"</span>,</div><div class="line">          onDone: [</div><div class="line">            &#123;</div><div class="line">              target: <span class="string">"build"</span>,</div><div class="line">            &#125;,</div><div class="line">          ],</div><div class="line">        &#125;,</div><div class="line">      &#125;,</div><div class="line">      build: &#123;</div><div class="line">        invoke: &#123;</div><div class="line">          src: <span class="function">(<span class="params">context, event</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> startAsyncTask();</div><div class="line">          &#125;,</div><div class="line">          id: <span class="string">"taskBuild"</span>,</div><div class="line">          onDone: [</div><div class="line">            &#123;</div><div class="line">              target: <span class="string">"publish"</span>,</div><div class="line">            &#125;,</div><div class="line">          ],</div><div class="line">        &#125;,</div><div class="line">      &#125;,</div><div class="line">      publish: &#123;</div><div class="line">        invoke: &#123;</div><div class="line">          src: <span class="function">(<span class="params">context, event</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> startAsyncTask();</div><div class="line">          &#125;,</div><div class="line">          id: <span class="string">"publishToCdn"</span>,</div><div class="line">          onDone: [</div><div class="line">            &#123;</div><div class="line">              target: <span class="string">"success"</span>,</div><div class="line">            &#125;,</div><div class="line">          ],</div><div class="line">        &#125;,</div><div class="line">      &#125;,</div><div class="line">      success: &#123;</div><div class="line">        type: <span class="string">"final"</span>,</div><div class="line">      &#125;,</div><div class="line">      failure: &#123;</div><div class="line">        type: <span class="string">"final"</span>,</div><div class="line">        on: &#123;</div><div class="line">          RETRY: &#123;</div><div class="line">            target: <span class="string">"idle"</span>,</div><div class="line">          &#125;,</div><div class="line">        &#125;,</div><div class="line">      &#125;,</div><div class="line">    &#125;,</div><div class="line">  &#125;);</div><div class="line"></div><div class="line"><span class="keyword">const</span> buildService = interpret(buildMachine).onTransition(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(state.value);</div><div class="line">  <span class="keyword">if</span> (state.value === <span class="string">'clone'</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(state.context.recordTime);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">buildService.start();</div><div class="line">buildService.send(<span class="string">'PREPARE_ENV'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 输出</span></div><div class="line">idle</div><div class="line">docker</div><div class="line">clone</div><div class="line">&#123;</div><div class="line">  docker: &#123; <span class="attr">start</span>: <span class="number">1668248311128</span>, <span class="attr">end</span>: <span class="number">1668248312130</span> &#125;,</div><div class="line">  clone: &#123; <span class="attr">start</span>: <span class="literal">undefined</span>, <span class="attr">end</span>: <span class="literal">undefined</span> &#125;,</div><div class="line">  install: &#123; <span class="attr">start</span>: <span class="literal">undefined</span>, <span class="attr">end</span>: <span class="literal">undefined</span> &#125;,</div><div class="line">  build: &#123; <span class="attr">start</span>: <span class="literal">undefined</span>, <span class="attr">end</span>: <span class="literal">undefined</span> &#125;</div><div class="line">&#125;</div><div class="line">build</div><div class="line">publish</div><div class="line">success</div></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述用状态机模拟了一个简单的构建过程，其实还有很多值得深究的地方，比如check阶段使用并行状态来进行多种检查等等，另外构建平台也有更多提高稳定性的逻辑，gitlab-ci构建方式也有docker in docker、bash等不同的方式，有兴趣的话可以后续再更新几篇关于云构建的文章</p><p>最后的最后，欢迎关注个人的github博客</p><p><strong>参考资料</strong><br><a href=""></a></p><p><img src="https://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在升级团队云构建的工具，由于构建任务的状态跳转很复杂，早期的IF-ELSE写法已经无法满足任务管理的扩展了，比如我想加一个代码规则的校验，那我就需要加上新的条件分支，各种IF-ELSE散落到各种异步逻辑中，这就给后续产品逻辑调整继续增加负担，因此决定用状态机来描述构建任务的流转，让逻辑变得可预测。&lt;/p&gt;
&lt;p&gt;本文的重点是介绍用状态机描述一个云构建任务的流转，具体的构建方式可以根据自己团队的实际情况来设计&lt;/p&gt;
&lt;p&gt;闲言少叙，开始&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="https://zhyjor.github.io/categories/node/"/>
    
    
      <category term="状态机,node" scheme="https://zhyjor.github.io/tags/%E7%8A%B6%E6%80%81%E6%9C%BA-node/"/>
    
  </entry>
  
  <entry>
    <title>v8之道二：GC</title>
    <link href="https://zhyjor.github.io/2022/09/08/v8%E4%B9%8B%E9%81%93%E4%BA%8C%EF%BC%9AGC/"/>
    <id>https://zhyjor.github.io/2022/09/08/v8之道二：GC/</id>
    <published>2022-09-08T09:09:57.000Z</published>
    <updated>2023-10-11T02:22:23.796Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>参考资料</strong><br><a href=""></a></p><p><img src="https://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.zhyjor.com/wexin.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="dev" scheme="https://zhyjor.github.io/categories/dev/"/>
    
    
      <category term="dev" scheme="https://zhyjor.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>typescript技巧之一：参数类型约束</title>
    <link href="https://zhyjor.github.io/2022/07/28/typescript%E6%8A%80%E5%B7%A7%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F/"/>
    <id>https://zhyjor.github.io/2022/07/28/typescript技巧之一：参数类型约束/</id>
    <published>2022-07-28T07:48:01.000Z</published>
    <updated>2023-10-11T02:22:23.796Z</updated>
    
    <content type="html"><![CDATA[<p>日常开发中我们经常会遇到<em>标记联合类型</em>了，一般都是出现在需要辨析联合类型的情况下，比如Redux中，一般就经常使用type来区分不同的action，进而通过判断语句进行类型守护<br><a id="more"></a><br>比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">interface Square &#123;</div><div class="line">  kind: <span class="string">'square'</span>;</div><div class="line">  size: number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface Rectangle &#123;</div><div class="line">  kind: <span class="string">'rectangle'</span>;</div><div class="line">  width: number;</div><div class="line">  height: number;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 有人仅仅是添加了 `Circle` 类型</span></div><div class="line"><span class="comment">// 我们可能希望 TypeScript 能在任何被需要的地方抛出错误</span></div><div class="line">interface Circle &#123;</div><div class="line">  kind: <span class="string">'circle'</span>;</div><div class="line">  radius: number;</div><div class="line">&#125;</div><div class="line"></div><div class="line">type Shape = Square | Rectangle | Circle;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (s.kind) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'square'</span>:</div><div class="line">      <span class="keyword">return</span> s.size * s.size;</div><div class="line">    <span class="keyword">case</span> <span class="string">'rectangle'</span>:</div><div class="line">      <span class="keyword">return</span> s.width * s.height;</div><div class="line">    <span class="keyword">case</span> <span class="string">'circle'</span>:</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">const</span> _exhaustiveCheck: never = s;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>参考资料</strong><br><a href=""></a></p><p><img src="https://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日常开发中我们经常会遇到&lt;em&gt;标记联合类型&lt;/em&gt;了，一般都是出现在需要辨析联合类型的情况下，比如Redux中，一般就经常使用type来区分不同的action，进而通过判断语句进行类型守护&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="https://zhyjor.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zhyjor.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="typescript" scheme="https://zhyjor.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>你会配babel了吗</title>
    <link href="https://zhyjor.github.io/2022/07/27/%E4%BD%A0%E4%BC%9A%E9%85%8Dbabel%E4%BA%86%E5%90%97/"/>
    <id>https://zhyjor.github.io/2022/07/27/你会配babel了吗/</id>
    <published>2022-07-27T11:45:08.000Z</published>
    <updated>2023-10-11T02:22:23.800Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>参考资料</strong><br><a href=""></a></p><p><img src="http://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zhyjor.com/wexin.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="dev" scheme="https://zhyjor.github.io/categories/dev/"/>
    
    
      <category term="dev" scheme="https://zhyjor.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>详解js模块机制</title>
    <link href="https://zhyjor.github.io/2022/07/26/%E8%AF%A6%E8%A7%A3js%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/"/>
    <id>https://zhyjor.github.io/2022/07/26/详解js模块机制/</id>
    <published>2022-07-26T10:58:36.000Z</published>
    <updated>2023-10-11T02:22:23.808Z</updated>
    
    <content type="html"><![CDATA[<p>详解js模块机制<br><a id="more"></a></p><p><strong>参考资料</strong><br><a href="https://blog.51cto.com/u_15543482/5256932" target="_blank" rel="external">浅谈前端模块化</a><br><a href="https://blog.51cto.com/u_5650011/5394926" target="_blank" rel="external">前端模块化详解(完整版)</a></p><p><img src="https://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;详解js模块机制&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="https://zhyjor.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://zhyjor.github.io/tags/js/"/>
    
      <category term="模块" scheme="https://zhyjor.github.io/tags/%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>typescript实战之二：全局类型封装</title>
    <link href="https://zhyjor.github.io/2022/07/22/typescript%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BA%8C%EF%BC%9A%E5%85%A8%E5%B1%80%E7%B1%BB%E5%9E%8B%E5%B0%81%E8%A3%85/"/>
    <id>https://zhyjor.github.io/2022/07/22/typescript实战之二：全局类型封装/</id>
    <published>2022-07-22T06:57:25.000Z</published>
    <updated>2023-10-11T02:22:23.796Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>参考资料</strong><br><a href=""></a></p><p><img src="http://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zhyjor.com/wexin.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="dev" scheme="https://zhyjor.github.io/categories/dev/"/>
    
    
      <category term="dev" scheme="https://zhyjor.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>typescript实战之一：工具类型</title>
    <link href="https://zhyjor.github.io/2022/07/22/typescript%E5%AE%9E%E6%88%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B/"/>
    <id>https://zhyjor.github.io/2022/07/22/typescript实战之一：工具类型/</id>
    <published>2022-07-22T06:56:47.000Z</published>
    <updated>2023-10-11T02:22:23.796Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>参考资料</strong><br><a href=""></a></p><p><img src="http://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zhyjor.com/wexin.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="dev" scheme="https://zhyjor.github.io/categories/dev/"/>
    
    
      <category term="dev" scheme="https://zhyjor.github.io/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>深入理解微前端之四：微前端的最佳实践</title>
    <link href="https://zhyjor.github.io/2022/07/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%9B%9B%EF%BC%9A%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://zhyjor.github.io/2022/07/22/深入理解微前端之四：微前端的最佳实践/</id>
    <published>2022-07-22T06:55:36.000Z</published>
    <updated>2023-10-11T02:22:23.808Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>参考资料</strong><br><a href=""></a></p><p><img src="http://static.zhyjor.com/wexin.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zhyjor.com/wexin.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="dev" scheme="https://zhyjor.github.io/categories/dev/"/>
    
    
      <category term="dev" scheme="https://zhyjor.github.io/tags/dev/"/>
    
  </entry>
  
</feed>
