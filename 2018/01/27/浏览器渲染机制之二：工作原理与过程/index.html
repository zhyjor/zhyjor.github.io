<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Neucha:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="浏览器,浏览器渲染机制," />





  <link rel="alternate" href="/atom.xml" title="秋染蒹葭" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0" />






<meta name="description" content="本文详细介绍浏览器渲染过程。">
<meta name="keywords" content="浏览器,浏览器渲染机制">
<meta property="og:type" content="article">
<meta property="og:title" content="浏览器渲染机制之二：工作原理与过程">
<meta property="og:url" content="https://zhyjor.github.io/2018/01/27/浏览器渲染机制之二：工作原理与过程/index.html">
<meta property="og:site_name" content="秋染蒹葭">
<meta property="og:description" content="本文详细介绍浏览器渲染过程。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://static.zhyjor.com/201808271121_974.png">
<meta property="og:image" content="http://static.zhyjor.com/201808271408_441.png">
<meta property="og:image" content="http://static.zhyjor.com/201808271410_452.png">
<meta property="og:image" content="http://static.zhyjor.com/201808271440_963.png">
<meta property="og:image" content="http://static.zhyjor.com/201808271500_155.png">
<meta property="og:image" content="http://static.zhyjor.com/201808271518_484.png">
<meta property="og:image" content="http://static.zhyjor.com/201808271526_904.png">
<meta property="og:image" content="http://static.zhyjor.com/201808271530_683.png">
<meta property="og:image" content="http://static.zhyjor.com/201808271542_423.png">
<meta property="og:image" content="http://static.zhyjor.com/201808271557_484.png">
<meta property="og:image" content="http://static.zhyjor.com/201808271723_145.png">
<meta property="og:image" content="http://static.zhyjor.com/201808271739_605.png">
<meta property="og:image" content="http://static.zhyjor.com/201808271753_901.png">
<meta property="og:image" content="http://static.zhyjor.com/201808271757_226.png">
<meta property="og:image" content="http://static.zhyjor.com/wexin.png">
<meta property="og:updated_time" content="2023-10-11T02:22:23.804Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浏览器渲染机制之二：工作原理与过程">
<meta name="twitter:description" content="本文详细介绍浏览器渲染过程。">
<meta name="twitter:image" content="http://static.zhyjor.com/201808271121_974.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zhyjor.github.io/2018/01/27/浏览器渲染机制之二：工作原理与过程/"/>





  <title> 浏览器渲染机制之二：工作原理与过程 | 秋染蒹葭 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?340874ba9357cbe81570aa4ac1185941";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <a href="https://github.com/zhyjor"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>

	<header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta custom-logo">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">秋染蒹葭</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <h1 class="site-subtitle" itemprop="description">会当凌绝顶，一览众山小</h1>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zhyjor.github.io/2018/01/27/浏览器渲染机制之二：工作原理与过程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="zhyjor">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="秋染蒹葭">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="秋染蒹葭" src="/images/avatar.jpg">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                浏览器渲染机制之二：工作原理与过程
              
            
          </h2>
        

        <div class="post-meta">
		
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-27T02:13:19+00:00">
                2018-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/浏览器/" itemprop="url" rel="index">
                    <span itemprop="name">浏览器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/01/27/浏览器渲染机制之二：工作原理与过程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/01/27/浏览器渲染机制之二：工作原理与过程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          
 
        


        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文详细介绍浏览器渲染过程。<br><a id="more"></a></p>
<h2 id="渲染引擎的详细介绍"><a href="#渲染引擎的详细介绍" class="headerlink" title="渲染引擎的详细介绍"></a>渲染引擎的详细介绍</h2><p>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示html、xml文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用PDF阅读器插件。这里只讨论渲染引擎最主要的用途——显示应用了CSS之后的html及图片。</p>
<h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><p>不同的浏览器有不同的渲染引擎，对于渲染引擎的使用总结如下：</p>
<ul>
<li>Trident(MSHTML)内核：IE,MaxThon,TT,The World,360,搜狗浏览器等</li>
<li>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</li>
<li>Presto内核：Opera7及以上</li>
<li>Webkit内核：Safari,Chrome等</li>
</ul>
<h3 id="渲染主流程"><a href="#渲染主流程" class="headerlink" title="渲染主流程"></a>渲染主流程</h3><p>渲染引擎首先通过网络获得所请求文档的内容，通常以8K分块的方式完成。下面是渲染引擎在取得内容之后的基本流程：</p>
<p><img src="http://static.zhyjor.com/201808271121_974.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</div></pre></td></tr></table></figure>
<ul>
<li>渲染引擎开始解析html，并将标签转化为内容树中的dom节点。</li>
<li>接着，它解析外部CSS文件及style标签中的样式信息。这些样式信息以及html中的可见性指令将被用来构建另一棵树——render树。Render树由一些包含有颜色和大小等属性的矩形组成，它们将被按照正确的顺序显示到屏幕上。 </li>
<li>Render树构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标。</li>
<li>再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。 </li>
</ul>
<p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<p>webkit主流程：<br><img src="http://static.zhyjor.com/201808271408_441.png" alt=""></p>
<p>Mozilla的Geoko渲染引擎主流程：<br><img src="http://static.zhyjor.com/201808271410_452.png" alt=""></p>
<p>尽管webkit和Gecko使用的术语稍有不同，他们的主要流程基本相同。Gecko称可见的格式化元素组成的树为frame树，每个元素都是一个frame，webkit则使用render树这个名词来命名由渲染对象组成的树。Webkit中元素的定位称为布局，而Gecko中称为回流。Webkit称利用dom节点及样式信息去构建render树的过程为attachment，Gecko在html和dom树之间附加了一层，这层称为内容接收器，相当制造dom元素的工厂。</p>
<h2 id="解析（Parsing－general）"><a href="#解析（Parsing－general）" class="headerlink" title="解析（Parsing－general）"></a>解析（Parsing－general）</h2><p>解析是渲染引擎中一个非常重要的过程，解析一个文档即将其转换为具有一定意义的结构——编码可以理解和使用的东西。HTML是一个纯文本的东西，计算机要怎么理解了？所以需要解析文档文档内容了嘛！所以HTML代码要遵守W3C的规范嘛！没有规则的东西是解析不了的！解析的结果通常是表达文档结构的节点树，称为解析树或语法树。</p>
<h3 id="语法（Grammars）"><a href="#语法（Grammars）" class="headerlink" title="语法（Grammars）"></a>语法（Grammars）</h3><p>解析基于文档依据的语法规则——文档的语言或格式。每种可被解析的格式必须具有由词汇及语法规则组成的特定的文法，所以HTML也是有语法规则的，按照语法规则来解析。</p>
<h3 id="解析器－词法分析器（Parser－Lexer-combination）"><a href="#解析器－词法分析器（Parser－Lexer-combination）" class="headerlink" title="解析器－词法分析器（Parser－Lexer combination）"></a>解析器－词法分析器（Parser－Lexer combination）</h3><p>解析可以分为两个子过程——语法分析及词法分析。语法分析指对语言应用语法规则。</p>
<p>解析器一般将工作分配给两个组件——词法分析器（有时也叫分词器）负责将输入分解为合法的符号，解析器则根据语言的语法规则分析文档结构，从而构建解析树，词法分析器知道怎么跳过空白和换行之类的无关字符。</p>
<p><img src="http://static.zhyjor.com/201808271440_963.png" alt=""></p>
<p>解析过程是迭代的，解析器从词法分析器处取到一个新的符号，并试着用这个符号匹配一条语法规则，如果匹配了一条规则，这个符号对应的节点将被添加到解析树上，然后解析器请求另一个符号。<strong>如果没有匹配到规则，解析器将在内部保存该符号，并从词法分析器取下一个符号，直到所有内部保存的符号能够匹配一项语法规则。</strong>如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。</p>
<h3 id="转换（Translation）"><a href="#转换（Translation）" class="headerlink" title="转换（Translation）"></a>转换（Translation）</h3><p>很多时候，解析树并不是最终结果。解析一般在转换中使用——将输入文档转换为另一种格式。编译就是个例子，编译器在将一段源码编译为机器码的时候，先将源码解析为解析树，然后将该树转换为一个机器码文档。</p>
<p><img src="http://static.zhyjor.com/201808271500_155.png" alt=""></p>
<h3 id="解析器类型（Types-of-parsers）"><a href="#解析器类型（Types-of-parsers）" class="headerlink" title="解析器类型（Types of parsers）"></a>解析器类型（Types of parsers）</h3><p>有两种基本的解析器——自顶向下解析及自底向上解析。比较直观的解释是，自顶向下解析，查看语法的最高层结构并试着匹配其中一个；自底向上解析则从输入开始，逐步将其转换为语法规则，从底层规则开始直到匹配高层规则。</p>
<h3 id="自动化解析（Generating-parsers-automatically）"><a href="#自动化解析（Generating-parsers-automatically）" class="headerlink" title="自动化解析（Generating parsers automatically）"></a>自动化解析（Generating parsers automatically）</h3><p>解析器生成器这个工具可以自动生成解析器，只需要指定语言的文法——词汇表及语法规则，它就可以生成一个解析器。创建一个解析器需要对解析有深入的理解，而且手动的创建一个有较好性能的解析器并不容易，所以解析生成器很有用。</p>
<p><strong>Webkit使用两个知名的解析生成器——用于创建语法分析器的Flex及创建解析器的Bison（你可能接触过Lex和Yacc）。Flex的输入是一个包含了符号定义的正则表达式，Bison的输入是用BNF格式表示的语法规则。</strong></p>
<h2 id="HTML解析器-HTML-Parser"><a href="#HTML解析器-HTML-Parser" class="headerlink" title="HTML解析器 HTML Parser"></a>HTML解析器 HTML Parser</h2><p>HTML解析器的工作是将html标识解析为解析树。</p>
<h3 id="HTML文法定义（The-HTML-grammar-definition）"><a href="#HTML文法定义（The-HTML-grammar-definition）" class="headerlink" title="HTML文法定义（The HTML grammar definition）"></a>HTML文法定义（The HTML grammar definition）</h3><p>W3C组织制定规范定义了HTML的词汇表和语法。</p>
<h3 id="非上下文无关文法（Not-a-context-free-grammar）"><a href="#非上下文无关文法（Not-a-context-free-grammar）" class="headerlink" title="非上下文无关文法（Not a context free grammar）"></a>非上下文无关文法（Not a context free grammar）</h3><p>上下文无关文法的语法可以用类似BNF的格式来定义。</p>
<p>不幸的是，所有的传统解析方式都不适用于html（当然我提出它们并不只是因为好玩，它们将用来解析css和js），html不能简单的用解析所需的上下文无关文法来定义。</p>
<p>Html有一个正式的格式定义——DTD（Document Type Definition文档类型定义）——但它并不是上下文无关文法，html更接近于xml，现在有很多可用的xml解析器，html有个xml的变体——xhtml，<strong>它们间的不同在于，html更宽容，它允许忽略一些特定标签，有时可以省略开始或结束标签</strong>。总的来说，它是一种soft语法，不像xml呆板、固执。</p>
<p>显然，这个看起来很小的差异却带来了很大的不同。一方面，这是html流行的原因——它的宽容使web开发人员的工作更加轻松，但另一方面，这也使很难去写一个格式化的文法。所以，html的解析并不简单，它既不能用传统的解析器解析，也不能用xml解析器解析。</p>
<h3 id="HTML-DTD"><a href="#HTML-DTD" class="headerlink" title="HTML DTD"></a>HTML DTD</h3><p>Html适用DTD格式进行定义，这一格式是用于定义SGML家族的语言，包括了对所有允许元素及它们的属性和层次关系的定义。正如前面提到的，html DTD并没有生成一种上下文无关文法。</p>
<p>DTD有一些变种，标准模式只遵守规范，而其他模式则包含了对浏览器过去所使用标签的支持，这么做是为了兼容以前内容。</p>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>输出的树，也就是解析树，是由DOM元素及属性节点组成的。DOM是文档对象模型的缩写，它是html文档的对象表示，作为html元素的外部接口供js等调用。树的根是“document”对象，DOM和标签基本是一一对应的关系。</p>
<p>和html一样，DOM的规范也是由W3C组织制定的。，这是使用文档的一般规范。</p>
<h3 id="解析算法（The-parsing-algorithm）"><a href="#解析算法（The-parsing-algorithm）" class="headerlink" title="解析算法（The parsing algorithm）"></a>解析算法（The parsing algorithm）</h3><p><strong>正如前面章节中讨论的，hmtl不能被一般的自顶向下或自底向上的解析器所解析。</strong></p>
<p>原因是：</p>
<ul>
<li>这门语言本身的宽容特性</li>
<li>浏览器对一些常见的非法html有容错机制</li>
<li>解析过程是往复的，通常源码不会在解析过程中发生改变，但在html中，脚本标签包含的“document.write”可能添加标签，这说明在解析过程中实际上修改了输入。</li>
</ul>
<p>不能使用正则解析技术，浏览器为html定制了专属的解析器。Html5规范中描述了这个解析算法，算法包括两个阶段——符号化及构建树。</p>
<ul>
<li>符号化是词法分析的过程，将输入解析为符号，html的符号包括开始标签、结束标签、属性名及属性值。</li>
<li>符号识别器识别出符号后，将其传递给树构建器，并读取下一个字符，以识别下一个符号，这样直到处理完所有输入。</li>
</ul>
<p><img src="http://static.zhyjor.com/201808271518_484.png" alt=""></p>
<h4 id="符号识别算法（The-tokenization-algorithm）"><a href="#符号识别算法（The-tokenization-algorithm）" class="headerlink" title="符号识别算法（The tokenization algorithm）"></a>符号识别算法（The tokenization algorithm）</h4><p>算法输出html符号，该算法用状态机表示。每次读取输入流中的一个或多个字符，并根据这些字符转移到下一个状态，当前的符号状态及构建树状态共同影响结果，这意味着，读取同样的字符，<strong>可能因为当前状态的不同，得到不同的结果以进入下一个正确的状态。</strong></p>
<p>这个算法很复杂，这里用一个简单的例子来解释这个原理。</p>
<p>基本示例——符号化下面的html：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">		Hello world</div><div class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>初始状态为“Data State”，当遇到“&lt;”字符，状态变为“Tag open state”，读取一个a－z的字符将产生一个开始标签符号，状态相应变为“Tag name state”，一直保持这个状态直到读取到“&gt;”，每个字符都附加到这个符号名上，例子中创建的是一个html符号。当读取到“&gt;”，当前的符号就完成了，此时，状态回到“Data state”，<code>&lt;body&gt;</code>重复这一处理过程。</p>
<p>这样直到遇到<code>“&lt;/body&gt;”</code>中的“&lt;”。现在，又回到了“Tag open state”，读取下一个字符“/”将创建一个闭合标签符号，并且状态转移到“Tag name state”，还是保持这一状态，直到遇到“&gt;”。然后，产生一个新的标签符号并回到“Data state”。后面的<code>“&lt;/html&gt;”</code>将和<code>“&lt;/body&gt;”</code>一样处理。</p>
<p><img src="http://static.zhyjor.com/201808271526_904.png" alt=""></p>
<h4 id="树的构建算法（Tree-construction-algorithm）"><a href="#树的构建算法（Tree-construction-algorithm）" class="headerlink" title="树的构建算法（Tree construction algorithm）"></a>树的构建算法（Tree construction algorithm）</h4><p>在树的构建阶段，将修改以Document为根的DOM树，将元素附加到树上。每个由符号识别器识别生成的节点将会被树构造器进行处理，规范中定义了每个符号相对应的Dom元素，对应的Dom元素将会被创建。这些元素除了会被添加到Dom树上，还将被添加到开放元素堆栈中。这个堆栈用来纠正嵌套的未匹配和未闭合标签，这个算法也是用状态机来描述，所有的状态采用插入模式。</p>
<p>来看一下示例中树的创建过程：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">   		<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"white-space:pre"</span>&gt;</span>	<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">		Hello world</div><div class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>构建树这一阶段的输入是符号识别阶段生成的符号序列。</strong></p>
<ul>
<li>首先是“initial mode”，接收到html符号后将转换为“before html”模式，在这个模式中对这个符号进行再处理。此时，创建了一个HTMLHtmlElement元素，并将其附加到根Document对象上。</li>
<li>状态此时变为“before head”，接收到body符号时，即使这里没有head符号，也将自动创建一个HTMLHeadElement元素并附加到树上。</li>
<li>现在，转到“in head”模式，然后是“after head”。到这里，body符号会被再次处理，将创建一个HTMLBodyElement并插入到树中，同时，转移到“in body”模式。</li>
<li>然后，接收到字符串“Hello world”的字符符号，第一个字符将导致创建并插入一个text节点，其他字符将附加到该节点。</li>
<li>接收到body结束符号时，转移到“after body”模式，接着接收到html结束符号，这个符号意味着转移到了“after after body”模式，当接收到文件结束符时，整个解析过程结束。</li>
</ul>
<p><img src="http://static.zhyjor.com/201808271530_683.png" alt=""></p>
<h4 id="解析结束时的处理（Action-when-the-parsing-is-finished）"><a href="#解析结束时的处理（Action-when-the-parsing-is-finished）" class="headerlink" title="解析结束时的处理（Action when the parsing is finished）"></a>解析结束时的处理（Action when the parsing is finished）</h4><p>在这个阶段，浏览器将文档标记为可交互的，并开始解析处于延时模式中的脚本——这些脚本在文档解析后执行。</p>
<p><strong>文档状态将被设置为完成，同时触发一个load事件。</strong></p>
<p><a href="http://www.w3.org/TR/html5/syntax.html#html-parser" target="_blank" rel="external">Html5规范中有符号化及构建树的完整算法</a>。</p>
<h3 id="浏览器容错（Browsers-error-tolerance）"><a href="#浏览器容错（Browsers-error-tolerance）" class="headerlink" title="浏览器容错（Browsers error tolerance）"></a>浏览器容错（Browsers error tolerance）</h3><p>你从来不会在一个html页面上看到“无效语法”这样的错误，浏览器修复了无效内容并继续工作。</p>
<p>浏览器都具有错误处理的能力，但是，另人惊讶的是，这并不是html最新规范的内容，就像书签及前进后退按钮一样，它只是浏览器长期发展的结果。一些比较知名的非法html结构，在许多站点中出现过，浏览器都试着以一种和其他浏览器一致的方式去修复。</p>
<p>Html5规范定义了这方面的需求，webkit在html解析类开始部分的注释中做了很好的总结。</p>
<p>解析器将符号化的输入解析为文档并创建文档，但不幸的是，我们必须处理很多没有很好格式化的html文档，至少要小心下面几种错误情况。</p>
<ul>
<li>在未闭合的标签中添加明确禁止的元素。这种情况下，应该先将前一标签闭合</li>
<li>不能直接添加元素。有些人在写文档的时候会忘了中间一些标签（或者中间标签是可选的），比如HTML HEAD BODY TR TD LI等</li>
<li>想在一个行内元素中添加块状元素。关闭所有的行内元素，直到下一个更高的块状元素</li>
<li>如果这些都不行，就闭合当前标签直到可以添加该元素。</li>
</ul>
<p>下面来看一些webkit容错的例子：</p>
<ul>
<li><code>&lt;/br&gt;</code>替代<code>&lt;br&gt;</code>,为了兼容IE和Firefox，webkit将其看作<code>&lt;br&gt;</code>。</li>
<li>太深的标签继承，最多只允许20个相同类型的标签嵌套，多出来的将被忽略。</li>
</ul>
<h2 id="CSS解析（CSS-parsing）"><a href="#CSS解析（CSS-parsing）" class="headerlink" title="CSS解析（CSS parsing）"></a>CSS解析（CSS parsing）</h2><p>不同于html，css属于上下文无关文法，可以用前面所描述的解析器来解析。Css规范定义了css的词法及语法文法。</p>
<p>看一些例子：</p>
<p>每个符号都由正则表达式定义了词法文法（词汇表）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">comment///*[^*]*/*+([^/*][^*]*/*+)*//</div><div class="line">num[0-9]+|[0-9]*&quot;.&quot;[0-9]+</div><div class="line">nonascii[/200-/377]</div><div class="line">nmstart[_a-z]|&#123;nonascii&#125;|&#123;escape&#125;</div><div class="line">nmchar[_a-z0-9-]|&#123;nonascii&#125;|&#123;escape&#125;</div><div class="line">name&#123;nmchar&#125;+ // “name”是一个元素id（用“＃”引用）</div><div class="line">ident&#123;nmstart&#125;&#123;nmchar&#125;* // “ident”是识别器的缩写，相当于一个class名</div></pre></td></tr></table></figure></p>
<p>语法用BNF进行描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">ruleset</div><div class="line">: selector [ &apos;,&apos; S* selector ]*</div><div class="line">&apos;&#123;&apos; S* declaration [ &apos;;&apos; S* declaration ]* &apos;&#125;&apos; S*</div><div class="line">;</div><div class="line">selector</div><div class="line">: simple_selector [ combinator selector | S+ [ combinator selector ] ]</div><div class="line">;</div><div class="line">simple_selector</div><div class="line">: element_name [ HASH | class | attrib | pseudo ]*</div><div class="line">| [ HASH | class | attrib | pseudo ]+</div><div class="line">;</div><div class="line">class</div><div class="line">: &apos;.&apos; IDENT</div><div class="line">;</div><div class="line">element_name</div><div class="line">: IDENT | &apos;*&apos;</div><div class="line">;</div><div class="line">attrib</div><div class="line">: &apos;[&apos; S* IDENT S* [ [ &apos;=&apos; | INCLUDES | DASHMATCH ] S*</div><div class="line">[ IDENT | STRING ] S* ] &apos;]&apos;</div><div class="line">;</div><div class="line">pseudo</div><div class="line">: &apos;:&apos; [ IDENT | FUNCTION S* [IDENT S*] &apos;)&apos; ]</div><div class="line">;</div><div class="line">说明：一个规则集合有这样的结构</div><div class="line">div.error , a.error &#123;</div><div class="line">color:red;</div><div class="line">font-weight:bold;</div><div class="line">&#125;</div><div class="line">div.error和a.error时选择器，大括号中的内容包含了这条规则集合中的规则，这个结构在下面的定义中正式的定义了：</div><div class="line">ruleset</div><div class="line">: selector [ &apos;,&apos; S* selector ]*</div><div class="line">&apos;&#123;&apos; S* declaration [ &apos;;&apos; S* declaration ]* &apos;&#125;&apos; S*</div><div class="line">;</div></pre></td></tr></table></figure>
<p>这说明，一个规则集合具有一个或是可选个数的多个选择器，这些选择器以逗号和空格（S表示空格）进行分隔。每个规则集合包含大括号及大括号中的一条或多条以分号隔开的声明。声明和选择器在后面进行定义。</p>
<h3 id="Webkit-CSS解析器（Webkit-CSS-parser）"><a href="#Webkit-CSS解析器（Webkit-CSS-parser）" class="headerlink" title="Webkit CSS解析器（Webkit CSS parser）"></a>Webkit CSS解析器（Webkit CSS parser）</h3><p>Webkit使用Flex和Bison解析生成器从CSS语法文件中自动生成解析器。回忆一下解析器的介绍，Bison创建一个自底向上的解析器，Firefox使用自顶向下解析器。它们都是将每个css文件解析为样式表对象，每个对象包含css规则，css规则对象包含选择器和声明对象，以及其他一些符合css语法的对象。</p>
<p><img src="http://static.zhyjor.com/201808271542_423.png" alt=""></p>
<h3 id="处理脚本及样式表的顺序"><a href="#处理脚本及样式表的顺序" class="headerlink" title="处理脚本及样式表的顺序"></a>处理脚本及样式表的顺序</h3><h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><p>web的模式是同步的，开发者希望解析到一个script标签时立即解析执行脚本，并阻塞文档的解析直到脚本执行完。如果脚本是外引的，则网络必须先请求到这个资源——这个过程也是同步的，会阻塞文档的解析直到资源被请求到。这个模式保持了很多年，并且在html4及html5中都特别指定了。开发者可以将脚本标识为defer，以使其不阻塞文档解析，并在文档解析结束后执行。Html5增加了标记脚本为异步asyn的选项，以使脚本的解析执行使用另一个线程。</p>
<h4 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h4><p>Webkit和Firefox都做了这个优化，当执行脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变Dom树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p>
<h4 id="样式表（Style-sheets）"><a href="#样式表（Style-sheets）" class="headerlink" title="样式表（Style sheets）"></a>样式表（Style sheets）</h4><p>样式表采用另一种不同的模式。理论上，既然样式表不改变Dom树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，脚本可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题，这看起来是个边缘情况，但确实很常见。Firefox在存在样式表还在加载和解析时阻塞所有的脚本，而Chrome只在当脚本试图访问某些可能被未加载的样式表所影响的特定的样式属性时才阻塞这些脚本。</p>
<h2 id="渲染树构建"><a href="#渲染树构建" class="headerlink" title="渲染树构建"></a>渲染树构建</h2><p>当Dom树构建完成时，浏览器开始构建另一棵树——渲染树。</p>
<p>渲染树由元素显示序列中的可见元素组成，它是文档的可视化表示，构建这棵树是为了以正确的顺序绘制文档内容。Firefox将渲染树中的元素称为frames，WebKit则用renderer或渲染对象来描述这些元素。</p>
<p>一个渲染对象知道怎么布局及绘制自己及它的children。</p>
<p>RenderObject是Webkit的渲染对象基类，它的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span>&#123;</span></div><div class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(PaintInfo)</span></span>;</div><div class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> rect <span class="title">repaintRect</span><span class="params">()</span></span>;</div><div class="line">   Node* node;<span class="comment">//the DOM node</span></div><div class="line">   RenderStyle* style;<span class="comment">// the computed style</span></div><div class="line">   RenderLayer* containgLayer; <span class="comment">//the containing z-index layer</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每个渲染对象用一个和该节点的css盒模型相对应的矩形区域来表示，正如css2所描述的那样，它包含诸如宽、高和位置之类的几何信息。盒模型的类型受该节点相关的display样式属性的影响（参考样式计算章节）。下面的webkit代码说明了如何根据display属性决定某个节点创建何种类型的渲染对象。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)</div><div class="line">&#123;</div><div class="line">	Document* doc = node-&gt;document();</div><div class="line">	RenderArena* arena = doc-&gt;renderArena();</div><div class="line">	...</div><div class="line">	RenderObject* o = <span class="number">0</span>;</div><div class="line">	<span class="keyword">switch</span> (style-&gt;display()) &#123;</div><div class="line">		<span class="keyword">case</span> NONE:</div><div class="line">		<span class="keyword">break</span>;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> INLINE:</div><div class="line">		o = <span class="keyword">new</span> (arena) RenderInline(node);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> BLOCK:</div><div class="line">		o = <span class="keyword">new</span> (arena) RenderBlock(node);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> INLINE_BLOCK:</div><div class="line">		o = <span class="keyword">new</span> (arena) RenderBlock(node);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> LIST_ITEM:</div><div class="line">		o = <span class="keyword">new</span> (arena) RenderListItem(node);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line"><span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>元素的类型也需要考虑，例如，表单控件和表格带有特殊的框架。</p>
<p>在Webkit中，如果一个元素想创建一个特殊的渲染对象，它需要重写“createRenderer”方法，使渲染对象指向不包含几何信息的样式对象。</p>
<h3 id="渲染树和Dom树的关系"><a href="#渲染树和Dom树的关系" class="headerlink" title="渲染树和Dom树的关系"></a>渲染树和Dom树的关系</h3><p>渲染对象和Dom元素相对应，但这种对应关系不是一对一的，<strong>不可见的Dom元素不会被插入渲染树，例如head元素。另外，display属性为none的元素也不会在渲染树中出现（visibility属性为hidden的元素将出现在渲染树中）。</strong></p>
<p>还有一些Dom元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。例如，<strong>select元素有三个渲染对象</strong>——一个显示区域、一个下拉列表及一个按钮。同样，当文本因为宽度不够而折行时，新行将作为额外的渲染元素被添加。另一个多个渲染对象的例子是不规范的html，根据css规范，一个行内元素只能仅包含行内元素或仅包含块状元素，在存在混合内容时，将会创建匿名的块状渲染对象包裹住行内元素。</p>
<p><strong>一些渲染对象和所对应的Dom节点不在树上相同的位置，例如，浮动和绝对定位的元素在文本流之外，在两棵树上的位置不同，渲染树上标识出真实的结构，并用一个占位结构标识出它们原来的位置。</strong></p>
<p><img src="http://static.zhyjor.com/201808271557_484.png" alt=""></p>
<h3 id="创建树的流程"><a href="#创建树的流程" class="headerlink" title="创建树的流程"></a>创建树的流程</h3><p>Firefox中，表述为一个监听Dom更新的监听器，将frame的创建委派给Frame Constructor，这个构建器计算样式（参看样式计算）并创建一个frame。</p>
<p>Webkit中，计算样式并生成渲染对象的过程称为attachment，每个Dom节点有一个attach方法，attachment的过程是同步的，调用新节点的attach方法将节点插入到Dom树中。</p>
<p>处理html和body标签将构建渲染树的根，这个根渲染对象对应被css规范称为containing block的元素——包含了其他所有块元素的顶级块元素。它的大小就是viewport——浏览器窗口的显示区域，Firefox称它为viewPortFrame，webkit称为RenderView，这个就是文档所指向的渲染对象，树中其他的部分都将作为一个插入的Dom节点被创建。</p>
<h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><p>创建渲染树需要计算出每个渲染对象的可视属性，这可以通过计算每个元素的样式属性得到。样式包括各种来源的样式表，行内样式元素及html中的可视化属性（例如bgcolor），可视化属性转化为css样式属性。</p>
<p>样式表来源于浏览器默认样式表，及页面作者和用户提供的样式表——有些样式是浏览器用户提供的（浏览器允许用户定义喜欢的样式，例如，在Firefox中，可以通过在Firefox Profile目录下放置样式表实现）。</p>
<p>计算样式的一些困难：</p>
<ul>
<li>样式数据是非常大的结构，保存大量的样式属性会带来内存问题。</li>
<li>如果不进行优化，找到每个元素匹配的规则会导致性能问题，为每个元素查找匹配的规则都需要遍历整个规则表，这个过程有很大的工作量。选择符可能有复杂的结构，匹配过程如果沿着一条开始看似正确，后来却被证明是无用的路径，则必须去尝试另一条路径。</li>
<li>应用规则涉及非常复杂的级联，它们定义了规则的层次</li>
</ul>
<p>我们来看一下浏览器如何处理这些问题：</p>
<h3 id="共享样式数据"><a href="#共享样式数据" class="headerlink" title="共享样式数据"></a>共享样式数据</h3><p>WebkKit节点引用样式对象（渲染样式），某些情况下，这些对象可以被节点间共享，这些节点需要是兄弟或是表兄弟节点，并且：</p>
<ul>
<li>这些元素必须处于相同的鼠标状态（比如不能一个处于hover，而另一个不是）</li>
<li>不能有元素具有id</li>
<li>标签名必须匹配</li>
<li>class属性必须匹配</li>
<li>对应的属性必须相同</li>
<li>链接状态必须匹配</li>
<li>焦点状态必须匹配</li>
<li>不能有元素被属性选择器影响</li>
<li>元素不能有行内样式属性</li>
<li>不能有生效的兄弟选择器，webcore在任何兄弟选择器相遇时只是简单的抛出一个全局转换，并且在它们显示时使整个文档的样式共享失效，这些包括＋选择器和类似<code>:first-child</code>和<code>:last-child</code>这样的选择器。</li>
</ul>
<h3 id="Firefox规则树"><a href="#Firefox规则树" class="headerlink" title="Firefox规则树"></a>Firefox规则树</h3><p>Firefox用两个树用来简化样式计算－规则树和样式上下文树，WebKit也有样式对象，但它们并没有存储在类似样式上下文树这样的树中，只是由Dom节点指向其相关的样式。</p>
<p><img src="http://static.zhyjor.com/201808271723_145.png" alt=""></p>
<p>样式上下文包含最终值，这些值是通过以正确顺序应用所有匹配的规则，并将它们由逻辑值转换为具体的值，例如，如果逻辑值为屏幕的百分比，则通过计算将其转化为绝对单位。样式树的使用确实很巧妙，它使得在节点中共享的这些值不需要被多次计算，同时也节省了存储空间。</p>
<p>总结一下，共享样式对象（结构中完整或部分内容）解决了问题1和3，Firefox的规则树帮助以正确的顺序应用规则。</p>
<h3 id="对规则进行处理以简化匹配过程"><a href="#对规则进行处理以简化匹配过程" class="headerlink" title="对规则进行处理以简化匹配过程"></a>对规则进行处理以简化匹配过程</h3><p>样式规则有几个来源：</p>
<ul>
<li>外部样式表或style标签内的css规则</li>
<li>行内样式属性</li>
<li>html可视化属性（映射为相应的样式规则）</li>
</ul>
<p>后面两个很容易匹配到元素，因为它们所拥有的样式属性和html属性可以将元素作为key进行映射。就像前面问题2所提到的，css的规则匹配可能很狡猾，为了解决这个问题，可以先对规则进行处理，以使其更容易被访问。</p>
<p>解析完样式表之后，规则会根据选择符添加一些hash映射，映射可以是根据id、class、标签名或是任何不属于这些分类的综合映射。如果选择符为id，规则将被添加到id映射，如果是class，则被添加到class映射，等等。</p>
<p>这个处理是匹配规则更容易，不需要查看每个声明，我们能从映射中找到一个元素的相关规则，这个优化使在进行规则匹配时减少了95+%的工作量。</p>
<p>Webkit和Firefox都会做这个处理。</p>
<h3 id="以正确的级联顺序应用规则"><a href="#以正确的级联顺序应用规则" class="headerlink" title="以正确的级联顺序应用规则"></a>以正确的级联顺序应用规则</h3><p>样式对象拥有对应所有可见属性的属性，如果特性没有被任何匹配的规则所定义，那么一些特性可以从parent的样式对象中继承，另外一些使用默认值。</p>
<p>这个问题的产生是因为存在不止一处的定义，这里用级联顺序解决这个问题。</p>
<h4 id="样式表的级联顺序"><a href="#样式表的级联顺序" class="headerlink" title="样式表的级联顺序"></a>样式表的级联顺序</h4><p>一个样式属性的声明可能在几个样式表中出现，或是在一个样式表中出现多次，因此，应用规则的顺序至关重要，这个顺序就是级联顺序。根据css2的规范，级联顺序为（从低到高）：</p>
<ul>
<li>浏览器声明</li>
<li>用户声明</li>
<li>作者的一般声明</li>
<li>作者的important声明</li>
<li>用户important声明</li>
</ul>
<p>浏览器声明是最不重要的，用户只有在声明被标记为important时才会覆盖作者的声明。具有同等级别的声明将根据specifity以及它们被定义时的顺序进行排序。Html可视化属性将被转换为匹配的css声明，它们被视为最低优先级的作者规则。</p>
<h4 id="Specifity"><a href="#Specifity" class="headerlink" title="Specifity"></a>Specifity</h4><p>Css2规范中定义的选择符specifity如下：</p>
<ul>
<li>如果声明来自style属性，而不是一个选择器的规则，则计1，否则计0（＝a）</li>
<li>计算选择器中id属性的数量（＝b）</li>
<li>计算选择器中class及伪类的数量（＝c）</li>
<li>计算选择器中元素名及伪元素的数量（＝d）</li>
</ul>
<p>连接a－b－c－d四个数量（用一个大基数的计算系统）将得到specifity。这里使用的基数由分类中最高的基数定义。例如，如果a为14，可以使用16进制。不同情况下，a为17时，则需要使用阿拉伯数字17作为基数，这种情况可能在这个选择符时发生html body div div …（选择符中有17个标签，一般不太可能）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">*&#123;&#125;<span class="comment">/* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</span></div><div class="line"><span class="selector-tag">li</span>&#123;&#125;<span class="comment">/* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</span></div><div class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-line</span> &#123;&#125;<span class="comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span></div><div class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;&#125;<span class="comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span></div><div class="line"><span class="selector-tag">ul</span> <span class="selector-tag">ol</span>+<span class="selector-tag">li</span>&#123;&#125;<span class="comment">/* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</span></div><div class="line"><span class="selector-tag">h1</span> + *<span class="selector-attr">[rel=up]</span>&#123;&#125;<span class="comment">/* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</span></div><div class="line"><span class="selector-tag">ul</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span><span class="selector-class">.red</span>&#123;&#125;<span class="comment">/* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</span></div><div class="line"><span class="selector-tag">li</span><span class="selector-class">.red</span><span class="selector-class">.level</span>&#123;&#125;<span class="comment">/* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</span></div><div class="line"><span class="selector-id">#x34y</span>&#123;&#125;<span class="comment">/* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</span></div><div class="line"><span class="comment">/* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</span></div></pre></td></tr></table></figure>
<h4 id="规则排序"><a href="#规则排序" class="headerlink" title="规则排序"></a>规则排序</h4><p>规则匹配后，需要根据级联顺序对规则进行排序，WebKit先将小列表用冒泡排序，再将它们合并为一个大列表，WebKit通过为规则复写“&gt;”操作来执行排序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;(CSSRuleData&amp; r1, CSSRuleData&amp; r2)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> spec1 = r1.selector()-&gt;specificity();</div><div class="line">  <span class="keyword">int</span> spec2 = r2.selector()-&gt;specificity();</div><div class="line">  <span class="keyword">return</span> (spec1 == spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="逐步处理Gradual-process"><a href="#逐步处理Gradual-process" class="headerlink" title="逐步处理Gradual process"></a>逐步处理Gradual process</h3><p>webkit使用一个标志位标识所有顶层样式表都已加载，如果在attch时样式没有完全加载，则放置占位符，并在文档中标记，一旦样式表完成加载就重新进行计算。</p>
<h2 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h2><p>当渲染对象被创建并添加到树中，它们并没有位置和大小，计算这些值的过程称为layout或reflow。</p>
<p><strong>Html使用基于流的布局模型，意味着大部分时间，可以以单一的途径进行几何计算。</strong>流中靠后的元素并不会影响前面元素的几何特性，所以布局可以在文档中从右向左、自上而下的进行。也存在一些例外，比如html tables。</p>
<p>坐标系统相对于根frame，使用top和left坐标。</p>
<p>布局是一个递归的过程，由根渲染对象开始，它对应html文档元素，布局继续递归的通过一些或所有的frame层级，为每个需要几何信息的渲染对象进行计算。</p>
<p>根渲染对象的位置是0,0，它的大小是viewport－浏览器窗口的可见部分。</p>
<p>所有的渲染对象都有一个layout或reflow方法，每个渲染对象调用需要布局的children的layout方法。</p>
<h3 id="Dirty-bit系统"><a href="#Dirty-bit系统" class="headerlink" title="Dirty bit系统"></a>Dirty bit系统</h3><p>为了不因为每个小变化都全部重新布局，浏览器使用一个dirty bit系统，一个渲染对象发生了变化或是被添加了，就标记它及它的children为dirty——需要layout。存在两个标识——dirty及children are dirty，children are dirty说明即使这个渲染对象可能没问题，但它至少有一个child需要layout。</p>
<h4 id="全局和增量layout"><a href="#全局和增量layout" class="headerlink" title="全局和增量layout"></a>全局和增量layout</h4><p>当layout在整棵渲染树触发时，称为全局layout，这可能在下面这些情况下发生：</p>
<ul>
<li>一个全局的样式改变影响所有的渲染对象，比如字号的改变。</li>
<li>窗口resize。</li>
</ul>
<p>layout也可以是增量的，这样只有标志为dirty的渲染对象会重新布局（也将导致一些额外的布局）。增量layout会在渲染对象dirty时异步触发，例如，当网络接收到新的内容并添加到Dom树后，新的渲染对象会添加到渲染树中。</p>
<p><img src="http://static.zhyjor.com/201808271739_605.png" alt=""></p>
<h4 id="异步和同步layout"><a href="#异步和同步layout" class="headerlink" title="异步和同步layout"></a>异步和同步layout</h4><p>增量layout的过程是异步的，Firefox为增量layout生成了reflow队列，以及一个调度执行这些批处理命令。WebKit也有一个计时器用来执行增量layout－遍历树，为dirty状态的渲染对象重新布局。</p>
<p>另外，当脚本请求样式信息时，例如“offsetHeight”，会同步的触发增量布局。</p>
<p>全局的layout一般都是同步触发。</p>
<p>有些时候，layout会被作为一个初始layout之后的回调，比如滑动条的滑动。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>当一个layout因为resize或是渲染位置改变（并不是大小改变）而触发时，渲染对象的大小将会从缓存中读取，而不会重新计算。</p>
<p>一般情况下，如果只有子树发生改变，则layout并不从根开始。这种情况发生在，变化发生在元素自身并且不影响它周围元素，例如，将文本插入文本域（否则，每次击键都将触发从根开始的重排）。</p>
<h3 id="layout过程"><a href="#layout过程" class="headerlink" title="layout过程"></a>layout过程</h3><p>layout一般有下面这几个部分：</p>
<ul>
<li>parent渲染对象决定它的宽度</li>
<li>parent渲染对象读取chilidren，并：</li>
<li><ul>
<li>放置child渲染对象（设置它的x和y）</li>
<li>在需要时（它们当前为dirty或是处于全局layout或者其他原因）调用child渲染对象的layout，这将计算child的高度</li>
<li>parent渲染对象使用child渲染对象的累积高度，以及margin和padding的高度来设置自己的高度－这将被parent渲染对象的parent使用</li>
<li>将dirty标识设置为false</li>
</ul>
</li>
</ul>
<p>Firefox使用一个“state”对象（nsHTMLReflowState）做为参数去布局（firefox称为reflow），state包含parent的宽度及其他内容。</p>
<p>Firefox布局的输出是一个“metrics”对象（nsHTMLReflowMetrics）。它包括渲染对象计算出的高度。 </p>
<h3 id="宽度计算"><a href="#宽度计算" class="headerlink" title="宽度计算"></a>宽度计算</h3><p>渲染对象的宽度使用容器的宽度、渲染对象样式中的宽度及margin、border进行计算。例如，下面这个div的宽度：</p>
<p>webkit中宽度的计算过程是（RenderBox类的calcWidth方法）：</p>
<ul>
<li>容器的宽度是容器的可用宽度和0中的最大值，这里的可用宽度为：<code>contentWidth=clientWidth()-paddingLeft()-paddingRight()</code>，clientWidth和clientHeight代表一个对象内部的不包括border和滑动条的大小</li>
<li>元素的宽度指样式属性width的值，它可以通过计算容器的百分比得到一个绝对值</li>
<li>加上水平方向上的border和padding</li>
</ul>
<p>到这里是最佳宽度的计算过程，现在计算宽度的最大值和最小值，如果最佳宽度大于最大宽度则使用最大宽度，如果小于最小宽度则使用最小宽度。最后缓存这个值，当需要layout但宽度未改变时使用。</p>
<h3 id="Line-breaking"><a href="#Line-breaking" class="headerlink" title="Line breaking"></a>Line breaking</h3><p>当一个渲染对象在布局过程中需要折行时，则暂停并告诉它的parent它需要折行，parent将创建额外的渲染对象并调用它们的layout。</p>
<h2 id="绘制（Painting）"><a href="#绘制（Painting）" class="headerlink" title="绘制（Painting）"></a>绘制（Painting）</h2><p>绘制阶段，遍历渲染树并调用渲染对象的paint方法将它们的内容显示在屏幕上，绘制使用UI基础组件，这在UI的章节有更多的介绍。</p>
<h3 id="全局和增量"><a href="#全局和增量" class="headerlink" title="全局和增量"></a>全局和增量</h3><p>和布局一样，绘制也可以是全局的——绘制完整的树——或增量的。在增量的绘制过程中，一些渲染对象以不影响整棵树的方式改变，改变的渲染对象使其在屏幕上的矩形区域失效，这将导致操作系统将其看作dirty区域，并产生一个paint事件，操作系统很巧妙的处理这个过程，并将多个区域合并为一个。Chrome中，这个过程更复杂些，因为渲染对象在不同的进程中，而不是在主进程中。Chrome在一定程度上模拟操作系统的行为，表现为监听事件并派发消息给渲染根，在树中查找到相关的渲染对象，重绘这个对象（往往还包括它的children）。</p>
<h3 id="绘制顺序"><a href="#绘制顺序" class="headerlink" title="绘制顺序"></a>绘制顺序</h3><p><a href="http://www.w3.org/TR/CSS21/zindex.html" target="_blank" rel="external">css2定义了绘制过程的顺序</a>，这个就是元素压入堆栈的顺序，这个顺序影响着绘制，堆栈从后向前进行绘制。</p>
<p>一个块渲染对象的堆栈顺序是：</p>
<ul>
<li>背景色</li>
<li>背景图</li>
<li>border</li>
<li>children</li>
<li>outline</li>
</ul>
<h3 id="Firefox显示列表"><a href="#Firefox显示列表" class="headerlink" title="Firefox显示列表"></a>Firefox显示列表</h3><p>Firefox读取渲染树并为绘制的矩形创建一个显示列表，该列表以正确的绘制顺序包含这个矩形相关的渲染对象。</p>
<p>用这样的方法，可以使重绘时只需查找一次树，而不需要多次查找——绘制所有的背景、所有的图片、所有的border等等。</p>
<p>Firefox优化了这个过程，它不添加会被隐藏的元素，比如元素完全在其他不透明元素下面。</p>
<h3 id="WebKit矩形存储"><a href="#WebKit矩形存储" class="headerlink" title="WebKit矩形存储"></a>WebKit矩形存储</h3><p>重绘前，WebKit将旧的矩形保存为位图，然后只绘制新旧矩形的差集。</p>
<h2 id="动态变化和渲染引擎的线程"><a href="#动态变化和渲染引擎的线程" class="headerlink" title="动态变化和渲染引擎的线程"></a>动态变化和渲染引擎的线程</h2><h3 id="动态变化"><a href="#动态变化" class="headerlink" title="动态变化"></a>动态变化</h3><p>浏览器总是试着以最小的动作响应一个变化，所以一个元素颜色的变化将只导致该元素的重绘，元素位置的变化将大致元素的布局和重绘，添加一个Dom节点，也会大致这个元素的布局和重绘。一些主要的变化，比如增加html元素的字号，将会导致缓存失效，从而引起整数的布局和重绘。</p>
<h3 id="渲染引擎的线程"><a href="#渲染引擎的线程" class="headerlink" title="渲染引擎的线程"></a>渲染引擎的线程</h3><p>渲染引擎是单线程的，除了网络操作以外，几乎所有的事情都在单一的线程中处理，在Firefox和Safari中，这是浏览器的主线程，Chrome中这是tab的主线程。</p>
<p>网络操作由几个并行线程执行，并行连接的个数是受限的（通常是2－6个）。</p>
<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>浏览器主线程是一个事件循环，它被设计为无限循环以保持执行过程的可用，等待事件（例如layout和paint事件）并执行它们。下面是Firefox的主要事件循环代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">while</span> (!mExiting)</div><div class="line">NS_ProcessNextEvent(thread);</div></pre></td></tr></table></figure></p>
<h2 id="CSS2可视模型（CSS2-visual-module）"><a href="#CSS2可视模型（CSS2-visual-module）" class="headerlink" title="CSS2可视模型（CSS2 visual module）"></a>CSS2可视模型（CSS2 visual module）</h2><h3 id="画布The-Canvas"><a href="#画布The-Canvas" class="headerlink" title="画布The Canvas"></a>画布The Canvas</h3><p>根据CSS2规范，术语canvas用来描述格式化的结构所渲染的空间——浏览器绘制内容的地方。画布对每个维度空间都是无限大的，但浏览器基于viewport的大小选择了一个初始宽度。</p>
<p>根据<a href="http://www.w3.org/TR/CSS2/zindex.html" target="_blank" rel="external">z-index文档</a>的定义，画布如果是包含在其他画布内则是透明的，否则浏览器会指定一个颜色。</p>
<h3 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h3><p>CSS盒模型描述了矩形盒，这些矩形盒是为文档树中的元素生成的，并根据可视的格式化模型进行布局。每个box包括内容区域（如图片、文本等）及可选的四周padding、border和margin区域。</p>
<p><img src="http://static.zhyjor.com/201808271753_901.png" alt=""></p>
<p>每个节点生成0－n个这样的box。所有的元素都有一个display属性，用来决定它们生成box的类型，如block,inline等。默认的是inline，但浏览器样式表设置了其他默认值，例如，div元素默认为block。可以访问<a href="http://www.w3.org/TR/CSS2/sample.html" target="_blank" rel="external">官网</a>查看更多的默认样式表示例。</p>
<h3 id="定位策略Position-scheme"><a href="#定位策略Position-scheme" class="headerlink" title="定位策略Position scheme"></a>定位策略Position scheme</h3><p>这里有三种策略：</p>
<ul>
<li>normal －对象根据它在文档的中位置定位，这意味着它在渲染树和在Dom树中位置一致，并根据它的盒模型和大小进行布局。</li>
<li>float －对象先像普通流一样布局，然后尽可能的向左或是向右移动。</li>
<li>absolute －对象在渲染树中的位置和Dom树中位置无关。</li>
</ul>
<p>static和relative是normal，absolute和fixed属于absolute。在static定位中，不定义位置而使用默认的位置。其他策略中，作者指定位置——top、bottom、left、right。</p>
<p>Box布局的方式由这几项决定：box的类型、box的大小、定位策略及扩展信息（比如图片大小和屏幕尺寸）。</p>
<h4 id="Box类型"><a href="#Box类型" class="headerlink" title="Box类型"></a>Box类型</h4><ul>
<li>Block box：构成一个块，即在浏览器窗口上有自己的矩形</li>
<li>Inline box：并没有自己的块状区域，但包含在一个块状区域内</li>
<li>block一个挨着一个垂直格式化，inline则在水平方向上格式化。</li>
<li>Inline盒模型放置在行内或是line box中，每行至少和最高的box一样高，当box以baseline对齐时——即一个元素的底部和另一个box上除底部以外的某点对齐，行高可以比最高的box高。当容器宽度不够时，行内元素将被放到多行中，这在一个p元素中经常发生。</li>
</ul>
<p><img src="http://static.zhyjor.com/201808271757_226.png" alt=""></p>
<h3 id="定位Position"><a href="#定位Position" class="headerlink" title="定位Position"></a>定位Position</h3><ul>
<li>Relative相对定位——先按照一般的定位，然后按所要求的差值移动。</li>
<li>Absolute和Fixed,这种情况下的布局完全不顾普通的文档流，元素不属于文档流的一部分，大小取决于容器。Fixed时，容器为viewport（可视区域）。fixed即使在文档流滚动时也不会移动。</li>
</ul>
<h3 id="Layered-representation"><a href="#Layered-representation" class="headerlink" title="Layered representation"></a>Layered representation</h3><p>这个由CSS属性中的z-index指定，表示盒模型的第三个大小，即在z轴上的位置。Box分发到堆栈中（称为堆栈上下文），每个堆栈中靠后的元素将被较早绘制，栈顶靠前的元素离用户最近，当发生交叠时，将隐藏靠后的元素。堆栈根据z-index属性排序，拥有z-index属性的box形成了一个局部堆栈，viewport有外部堆栈.</p>
<p><strong>参考资料</strong><br><a href="https://blog.csdn.net/lxcao/article/category/6472061" target="_blank" rel="external"> 浏览器工作原理（十篇，质量一般）</a></p>
<p><img src="http://static.zhyjor.com/wexin.png" alt=""></p>

      
    </div>

	<div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">
  <p><span>本文标题:</span><a href="/2018/01/27/浏览器渲染机制之二：工作原理与过程/">浏览器渲染机制之二：工作原理与过程</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 zhyjor 的个人博客">zhyjor</a></p>
  <p><span>发布时间:</span>2018年01月27日 - 10:01</p>
  <p><span>最后更新:</span>2023年10月11日 - 02:10</p>
  <p><span>原始链接:</span><a href="/2018/01/27/浏览器渲染机制之二：工作原理与过程/" title="浏览器渲染机制之二：工作原理与过程">https://zhyjor.github.io/2018/01/27/浏览器渲染机制之二：工作原理与过程/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://zhyjor.github.io/2018/01/27/浏览器渲染机制之二：工作原理与过程/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
	clipboard.on('success', $(function(){
	  $(".fa-clipboard").click(function(){
		swal({   
		  title: "",   
		  text: '复制成功',   
		  html: false,
		  timer: 500,   
		  showConfirmButton: false
	    });
	  });
    }));  
</script>

      
	</div>
	
    <div>
      
        

      
    </div>
  
        <div class="post-tags">
          
            <a href="/tags/浏览器/" rel="tag"># 浏览器</a>
          
            <a href="/tags/浏览器渲染机制/" rel="tag"># 浏览器渲染机制</a>
          
        </div>
      


    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>🐶 您的支持将鼓励我继续创作 🐶</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赞赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat-reward-img.jpg" alt="zhyjor WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay-reward-img.jpg" alt="zhyjor Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>


    <footer class="post-footer">
         
      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/25/浏览器中window属性详解之一：location/" rel="next" title="浏览器中window属性详解之一：location">
                <i class="fa fa-chevron-left"></i> 浏览器中window属性详解之一：location
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/27/学点linux之一：常用命令/" rel="prev" title="学点linux之一：常用命令">
                学点linux之一：常用命令 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="monthly" data-num-items="4"></div>


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMTE5Ny83NzQ2"></div>
	
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="zhyjor" />
          <p class="site-author-name" itemprop="name">zhyjor</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">336</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">62</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">182</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhyjor" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/zhyjor" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/zhyjor" target="_blank" title="zhihu">
                  
                    <i class="fa fa-fw fa-battery-3"></i>
                  
                  zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.woaitqs.cc/" title="Qisen Tang" target="_blank">Qisen Tang</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://szhshp.org" title="szhshp的博客" target="_blank">szhshp的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://python.zhangwei.website" title="JuniorCoder" target="_blank">JuniorCoder</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://hippo-jessy.com" title="Hippo" target="_blank">Hippo</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.zhihu.com/people/lippi-ouyang" title="友链出租" target="_blank">友链出租</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#渲染引擎的详细介绍"><span class="nav-number">1.</span> <span class="nav-text">渲染引擎的详细介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#渲染引擎"><span class="nav-number">1.1.</span> <span class="nav-text">渲染引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#渲染主流程"><span class="nav-number">1.2.</span> <span class="nav-text">渲染主流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解析（Parsing－general）"><span class="nav-number">2.</span> <span class="nav-text">解析（Parsing－general）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法（Grammars）"><span class="nav-number">2.1.</span> <span class="nav-text">语法（Grammars）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析器－词法分析器（Parser－Lexer-combination）"><span class="nav-number">2.2.</span> <span class="nav-text">解析器－词法分析器（Parser－Lexer combination）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转换（Translation）"><span class="nav-number">2.3.</span> <span class="nav-text">转换（Translation）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析器类型（Types-of-parsers）"><span class="nav-number">2.4.</span> <span class="nav-text">解析器类型（Types of parsers）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动化解析（Generating-parsers-automatically）"><span class="nav-number">2.5.</span> <span class="nav-text">自动化解析（Generating parsers automatically）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTML解析器-HTML-Parser"><span class="nav-number">3.</span> <span class="nav-text">HTML解析器 HTML Parser</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML文法定义（The-HTML-grammar-definition）"><span class="nav-number">3.1.</span> <span class="nav-text">HTML文法定义（The HTML grammar definition）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非上下文无关文法（Not-a-context-free-grammar）"><span class="nav-number">3.2.</span> <span class="nav-text">非上下文无关文法（Not a context free grammar）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML-DTD"><span class="nav-number">3.3.</span> <span class="nav-text">HTML DTD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM"><span class="nav-number">3.4.</span> <span class="nav-text">DOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析算法（The-parsing-algorithm）"><span class="nav-number">3.5.</span> <span class="nav-text">解析算法（The parsing algorithm）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#符号识别算法（The-tokenization-algorithm）"><span class="nav-number">3.5.1.</span> <span class="nav-text">符号识别算法（The tokenization algorithm）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树的构建算法（Tree-construction-algorithm）"><span class="nav-number">3.5.2.</span> <span class="nav-text">树的构建算法（Tree construction algorithm）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解析结束时的处理（Action-when-the-parsing-is-finished）"><span class="nav-number">3.5.3.</span> <span class="nav-text">解析结束时的处理（Action when the parsing is finished）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器容错（Browsers-error-tolerance）"><span class="nav-number">3.6.</span> <span class="nav-text">浏览器容错（Browsers error tolerance）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS解析（CSS-parsing）"><span class="nav-number">4.</span> <span class="nav-text">CSS解析（CSS parsing）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Webkit-CSS解析器（Webkit-CSS-parser）"><span class="nav-number">4.1.</span> <span class="nav-text">Webkit CSS解析器（Webkit CSS parser）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理脚本及样式表的顺序"><span class="nav-number">4.2.</span> <span class="nav-text">处理脚本及样式表的顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#脚本"><span class="nav-number">4.2.1.</span> <span class="nav-text">脚本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#预解析"><span class="nav-number">4.2.2.</span> <span class="nav-text">预解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#样式表（Style-sheets）"><span class="nav-number">4.2.3.</span> <span class="nav-text">样式表（Style sheets）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#渲染树构建"><span class="nav-number">5.</span> <span class="nav-text">渲染树构建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#渲染树和Dom树的关系"><span class="nav-number">5.1.</span> <span class="nav-text">渲染树和Dom树的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建树的流程"><span class="nav-number">5.2.</span> <span class="nav-text">创建树的流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#样式计算"><span class="nav-number">5.3.</span> <span class="nav-text">样式计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享样式数据"><span class="nav-number">5.4.</span> <span class="nav-text">共享样式数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Firefox规则树"><span class="nav-number">5.5.</span> <span class="nav-text">Firefox规则树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对规则进行处理以简化匹配过程"><span class="nav-number">5.6.</span> <span class="nav-text">对规则进行处理以简化匹配过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#以正确的级联顺序应用规则"><span class="nav-number">5.7.</span> <span class="nav-text">以正确的级联顺序应用规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#样式表的级联顺序"><span class="nav-number">5.7.1.</span> <span class="nav-text">样式表的级联顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Specifity"><span class="nav-number">5.7.2.</span> <span class="nav-text">Specifity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#规则排序"><span class="nav-number">5.7.3.</span> <span class="nav-text">规则排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逐步处理Gradual-process"><span class="nav-number">5.8.</span> <span class="nav-text">逐步处理Gradual process</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布局（Layout）"><span class="nav-number">6.</span> <span class="nav-text">布局（Layout）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dirty-bit系统"><span class="nav-number">6.1.</span> <span class="nav-text">Dirty bit系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全局和增量layout"><span class="nav-number">6.1.1.</span> <span class="nav-text">全局和增量layout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步和同步layout"><span class="nav-number">6.1.2.</span> <span class="nav-text">异步和同步layout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优化"><span class="nav-number">6.1.3.</span> <span class="nav-text">优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#layout过程"><span class="nav-number">6.2.</span> <span class="nav-text">layout过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#宽度计算"><span class="nav-number">6.3.</span> <span class="nav-text">宽度计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Line-breaking"><span class="nav-number">6.4.</span> <span class="nav-text">Line breaking</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绘制（Painting）"><span class="nav-number">7.</span> <span class="nav-text">绘制（Painting）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#全局和增量"><span class="nav-number">7.1.</span> <span class="nav-text">全局和增量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绘制顺序"><span class="nav-number">7.2.</span> <span class="nav-text">绘制顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Firefox显示列表"><span class="nav-number">7.3.</span> <span class="nav-text">Firefox显示列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebKit矩形存储"><span class="nav-number">7.4.</span> <span class="nav-text">WebKit矩形存储</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态变化和渲染引擎的线程"><span class="nav-number">8.</span> <span class="nav-text">动态变化和渲染引擎的线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态变化"><span class="nav-number">8.1.</span> <span class="nav-text">动态变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#渲染引擎的线程"><span class="nav-number">8.2.</span> <span class="nav-text">渲染引擎的线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#事件循环"><span class="nav-number">8.2.1.</span> <span class="nav-text">事件循环</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS2可视模型（CSS2-visual-module）"><span class="nav-number">9.</span> <span class="nav-text">CSS2可视模型（CSS2 visual module）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#画布The-Canvas"><span class="nav-number">9.1.</span> <span class="nav-text">画布The Canvas</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS盒模型"><span class="nav-number">9.2.</span> <span class="nav-text">CSS盒模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定位策略Position-scheme"><span class="nav-number">9.3.</span> <span class="nav-text">定位策略Position scheme</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Box类型"><span class="nav-number">9.3.1.</span> <span class="nav-text">Box类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定位Position"><span class="nav-number">9.4.</span> <span class="nav-text">定位Position</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Layered-representation"><span class="nav-number">9.5.</span> <span class="nav-text">Layered representation</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhyjor</span>
</div>



<!--
<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" rel="external nofollow">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow">
    NexT.Mist
  </a>
</div>
-->

<div class="powered-by">
<i class="fa fa-user-md"></i>
<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共338.7k字</span>
</div>





        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ezlippi"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="//cdn.jsdelivr.net/ua-parser.js/0.7.10/ua-parser.min.js"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  














  
  

  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
<div id="hexo-helper-live2d">
  <canvas id="live2dcanvas" width="150" height="300"></canvas>
</div>
<style>
  #live2dcanvas{
    position: fixed;
    width: 150px;
    height: 300px;
    opacity:0.7;
    right: 0px;
    z-index: 999;
    pointer-events: none;
    bottom: -20px;
  }
</style>
<script type="text/javascript" src="/live2d/device.min.js"></script>
<script type="text/javascript">
const loadScript = function loadScript(c,b){var a=document.createElement("script");a.type="text/javascript";"undefined"!=typeof b&&(a.readyState?a.onreadystatechange=function(){if("loaded"==a.readyState||"complete"==a.readyState)a.onreadystatechange=null,b()}:a.onload=function(){b()});a.src=c;document.body.appendChild(a)};
(function(){
  if((typeof(device) != 'undefined') && (device.mobile())){
    document.getElementById("live2dcanvas").style.width = '75px';
    document.getElementById("live2dcanvas").style.height = '150px';
  }else
    if (typeof(device) === 'undefined') console.error('Cannot find current-device script.');
  loadScript("/live2d/script.js", function(){loadlive2d("live2dcanvas", "/live2d/assets/tororo.model.json", 0.5);});
})();
</script>

<style>
#live2dcanvas{
  position: fixed;
	bottom: 0px;
	left: 0px;
	z-index: 999;
	width: 150px;
	height: 300px;
  pointer-events: none;
  opacity: 1;
}
</style>
</body>
</html>
